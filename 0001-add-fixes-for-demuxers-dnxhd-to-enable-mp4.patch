From 67645e47ea782da8d807307b0351e33e3c921b26 Mon Sep 17 00:00:00 2001
From: Daniel Charles <daniel.charles@intel.com>
Date: Fri, 11 Oct 2019 21:29:17 +0000
Subject: [PATCH] add fixes for demuxers dnxhd to enable mp4

Signed-off-by: Daniel Charles <daniel.charles@intel.com>
---
 libavcodec/dnxhddata.c         | 1177 ++++++++++++++++++++++++++
 libavcodec/dnxhddata.h         |   97 +++
 libavcodec/dnxhddec.c          |  741 +++++++++++++++++
 libavcodec/dnxhdenc.c          | 1411 ++++++++++++++++++++++++++++++++
 libavcodec/dnxhdenc.h          |  114 +++
 libavcodec/x86/dnxhdenc.asm    |   49 ++
 libavcodec/x86/dnxhdenc_init.c |   37 +
 7 files changed, 3626 insertions(+)
 create mode 100644 libavcodec/dnxhddata.c
 create mode 100644 libavcodec/dnxhddata.h
 create mode 100644 libavcodec/dnxhddec.c
 create mode 100644 libavcodec/dnxhdenc.c
 create mode 100644 libavcodec/dnxhdenc.h
 create mode 100644 libavcodec/x86/dnxhdenc.asm
 create mode 100644 libavcodec/x86/dnxhdenc_init.c

diff --git a/libavcodec/dnxhddata.c b/libavcodec/dnxhddata.c
new file mode 100644
index 0000000000..154be89860
--- /dev/null
+++ b/libavcodec/dnxhddata.c
@@ -0,0 +1,1177 @@
+/*
+ * VC3/DNxHD data.
+ * Copyright (c) 2007 SmartJog S.A., Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avcodec.h"
+#include "dnxhddata.h"
+#include "libavutil/common.h"
+
+/* The quantization tables below are in zigzag order! */
+
+/* Used in CID 1235, 1256, 1270 */
+static const uint8_t dnxhd_1235_luma_weight[] = {
+     0, 32, 32, 32, 33, 32, 32, 32,
+    32, 31, 32, 33, 33, 33, 33, 35,
+    36, 36, 34, 34, 36, 37, 37, 36,
+    36, 35, 36, 38, 39, 39, 37, 36,
+    37, 37, 39, 41, 42, 41, 39, 39,
+    40, 41, 42, 43, 42, 42, 41, 41,
+    41, 44, 47, 46, 46, 48, 51, 51,
+    50, 50, 53, 55, 55, 56, 60, 60,
+};
+
+/* Used in CID 1235, 1256 */
+static const uint8_t dnxhd_1235_chroma_weight[] = {
+     0, 32, 33, 34, 34, 33, 34, 35,
+    37, 40, 43, 42, 39, 38, 39, 41,
+    43, 44, 47, 50, 55, 61, 63, 56,
+    48, 46, 49, 54, 59, 58, 55, 58,
+    63, 65, 67, 74, 84, 82, 75, 72,
+    70, 74, 84, 87, 87, 94, 93, 81,
+    75, 78, 83, 89, 91, 86, 82, 85,
+    90, 90, 85, 79, 73, 73, 73, 73,
+};
+
+/* Used in CID 1237, 1253, 1259, 1273, 1274 */
+static const uint8_t dnxhd_1237_luma_weight[] = {
+     0,  32,  33,  34, 34, 36, 37, 36,
+    36,  37,  38,  38, 38, 39, 41, 44,
+    43,  41,  40,  41, 46, 49, 47, 46,
+    47,  49,  51,  54, 60, 62, 59, 55,
+    54,  56,  58,  61, 65, 66, 64, 63,
+    66,  73,  78,  79, 80, 79, 78, 78,
+    82,  87,  89,  90, 93, 95, 96, 97,
+    97, 100, 104, 102, 98, 98, 99, 99,
+};
+
+/* Used in CID 1237, 1253, 1259, 1273, 1274 */
+static const uint8_t dnxhd_1237_chroma_weight[] = {
+     0,  32,  36,  39, 39, 38, 39,  41,
+    45,  51,  57,  58, 53, 48, 47,  51,
+    55,  58,  66,  75, 81, 83, 82,  78,
+    73,  72,  74,  77, 83, 85, 83,  82,
+    89,  99,  96,  90, 94, 97, 99, 105,
+   109, 105,  95,  89, 92, 95, 94,  93,
+    92,  88,  89,  90, 93, 95, 96,  97,
+    97, 100, 104, 102, 98, 98, 99,  99,
+};
+
+/* Used in CID 1238, 1272 */
+static const uint8_t dnxhd_1238_luma_weight[] = {
+     0, 32, 32, 33, 34, 33, 33, 33,
+    33, 33, 33, 33, 33, 35, 37, 37,
+    36, 36, 35, 36, 38, 38, 36, 35,
+    36, 37, 38, 41, 42, 41, 39, 38,
+    38, 38, 39, 41, 42, 41, 39, 39,
+    40, 41, 43, 44, 44, 44, 44, 44,
+    45, 47, 47, 47, 49, 50, 51, 51,
+    51, 53, 55, 57, 58, 59, 57, 57,
+};
+
+/* Used in CID 1238, 1272 */
+static const uint8_t dnxhd_1238_chroma_weight[] = {
+     0, 32, 35, 35, 35, 34, 34, 35,
+    39, 43, 45, 45, 41, 39, 40, 41,
+    42, 44, 48, 55, 59, 63, 65, 59,
+    53, 52, 52, 55, 61, 62, 58, 58,
+    63, 66, 66, 65, 70, 74, 70, 66,
+    65, 68, 75, 77, 74, 74, 77, 76,
+    73, 73, 73, 73, 76, 80, 89, 90,
+    82, 77, 80, 86, 84, 82, 82, 82,
+};
+
+/* Used in CID 1241, 1271 */
+static const uint8_t dnxhd_1241_luma_weight[] = {
+     0, 32, 33, 34, 34, 35, 36, 37,
+    36, 37, 38, 38, 38, 39, 39, 40,
+    40, 38, 38, 39, 38, 37, 39, 41,
+    41, 42, 43, 45, 45, 46, 47, 46,
+    45, 43, 39, 37, 37, 40, 44, 45,
+    45, 46, 46, 46, 47, 47, 46, 44,
+    42, 43, 45, 47, 48, 49, 50, 49,
+    48, 46, 47, 48, 48, 49, 49, 49,
+};
+
+/* Used in CID 1241, 1271 */
+static const uint8_t dnxhd_1241_chroma_weight[] = {
+     0, 32, 36, 38, 37, 37, 40, 41,
+    40, 40, 42, 42, 41, 41, 41, 41,
+    42, 43, 44, 44, 45, 46, 46, 45,
+    44, 45, 45, 45, 45, 46, 47, 46,
+    45, 44, 42, 41, 43, 45, 45, 47,
+    48, 48, 48, 46, 47, 47, 46, 47,
+    46, 45, 45, 47, 48, 49, 50, 49,
+    48, 46, 48, 49, 48, 49, 49, 49,
+};
+
+static const uint8_t dnxhd_1242_luma_weight[] = {
+     0, 32, 33, 33, 34, 35, 36, 35,
+    33, 33, 35, 36, 37, 37, 38, 37,
+    37, 37, 36, 37, 37, 37, 38, 39,
+    37, 36, 37, 40, 42, 45, 46, 44,
+    41, 42, 44, 45, 47, 49, 50, 48,
+    46, 48, 49, 50, 52, 52, 50, 49,
+    47, 48, 50, 50, 51, 51, 50, 49,
+    49, 51, 52, 51, 49, 47, 47, 47,
+};
+
+static const uint8_t dnxhd_1242_chroma_weight[] = {
+     0, 32, 37, 42, 45, 45, 45, 44,
+    38, 37, 40, 42, 44, 49, 51, 47,
+    41, 40, 43, 44, 46, 48, 51, 54,
+    51, 47, 47, 45, 47, 50, 51, 49,
+    46, 47, 49, 47, 50, 55, 55, 51,
+    48, 49, 51, 51, 52, 52, 54, 54,
+    49, 49, 52, 53, 54, 54, 53, 53,
+    55, 59, 63, 62, 60, 60, 60, 60,
+};
+
+static const uint8_t dnxhd_1243_luma_weight[] = {
+     0, 32, 32, 33, 33, 35, 35, 35,
+    35, 35, 35, 35, 34, 35, 38, 40,
+    39, 37, 37, 37, 36, 35, 36, 38,
+    40, 41, 42, 44, 45, 44, 42, 41,
+    40, 38, 36, 36, 37, 38, 40, 43,
+    44, 45, 45, 45, 45, 45, 45, 41,
+    39, 41, 45, 47, 47, 48, 48, 48,
+    46, 44, 45, 47, 47, 48, 47, 47,
+};
+
+static const uint8_t dnxhd_1243_chroma_weight[] = {
+     0, 32, 36, 37, 36, 37, 39, 39,
+    41, 43, 43, 42, 41, 41, 41, 42,
+    43, 43, 43, 44, 44, 44, 46, 47,
+    46, 45, 45, 45, 45, 46, 44, 44,
+    45, 44, 42, 41, 43, 46, 45, 44,
+    45, 45, 45, 46, 46, 46, 45, 44,
+    45, 44, 45, 47, 47, 48, 49, 48,
+    46, 45, 46, 47, 47, 48, 47, 47,
+};
+
+static const uint8_t dnxhd_1250_luma_weight[] = {
+     0, 32, 32, 33, 34, 35, 35, 35,
+    34, 34, 35, 36, 36, 36, 36, 36,
+    37, 38, 38, 38, 38, 38, 39, 39,
+    38, 38, 39, 41, 43, 43, 42, 41,
+    40, 40, 39, 40, 41, 41, 39, 39,
+    40, 42, 47, 50, 47, 45, 46, 46,
+    44, 45, 46, 47, 49, 54, 58, 54,
+    48, 49, 54, 57, 60, 62, 63, 63,
+};
+
+static const uint8_t dnxhd_1250_chroma_weight[] = {
+     0, 32, 35, 36, 36, 35, 36, 39,
+    41, 43, 45, 44, 41, 39, 40, 42,
+    43, 43, 45, 48, 49, 51, 52, 50,
+    50, 51, 51, 51, 51, 52, 53, 54,
+    51, 49, 51, 52, 52, 56, 57, 55,
+    54, 54, 55, 56, 55, 58, 58, 58,
+    60, 61, 62, 62, 59, 57, 58, 58,
+    61, 59, 59, 59, 60, 62, 63, 63,
+};
+
+static const uint8_t dnxhd_1251_luma_weight[] = {
+     0, 32, 32, 34, 34, 34, 34, 35,
+    35, 35, 36, 37, 36, 36, 35, 36,
+    38, 38, 38, 38, 38, 38, 38, 38,
+    38, 38, 39, 41, 44, 43, 41, 40,
+    40, 40, 40, 39, 40, 41, 40, 39,
+    40, 43, 46, 46, 44, 44, 44, 42,
+    41, 43, 46, 48, 50, 55, 58, 53,
+    48, 50, 55, 58, 61, 62, 62, 62,
+};
+
+static const uint8_t dnxhd_1251_chroma_weight[] = {
+     0, 32, 35, 36, 36, 35, 36, 39,
+    41, 43, 45, 44, 41, 39, 40, 42,
+    43, 43, 45, 48, 48, 48, 50, 50,
+    50, 51, 51, 51, 51, 52, 53, 54,
+    51, 49, 51, 52, 52, 56, 57, 55,
+    54, 54, 55, 56, 55, 58, 58, 58,
+    60, 61, 62, 62, 59, 57, 58, 58,
+    61, 59, 59, 59, 61, 62, 62, 62,
+};
+
+/* Used in CID 1252, 1258 */
+static const uint8_t dnxhd_1252_luma_weight[] = {
+      0,  32,  34, 35, 36, 36, 36, 37,
+     36,  37,  39, 40, 41, 40, 40, 40,
+     41,  41,  42, 41, 41, 43, 44, 44,
+     45,  46,  48, 55, 60, 57, 52, 50,
+     49,  49,  52, 52, 53, 55, 58, 62,
+     65,  73,  82, 82, 80, 78, 73, 68,
+     71,  82,  90, 90, 88, 87, 90, 95,
+    100, 107, 103, 97, 95, 93, 99, 99,
+};
+
+/* Used in CID 1252, 1258 */
+static const uint8_t dnxhd_1252_chroma_weight[] = {
+      0,  32,  35,  36,  37,  37,  38,  40,
+     42,  46,  49,  50,  50,  49,  49,  53,
+     56,  56,  57,  58,  60,  62,  64,  65,
+     63,  64,  64,  65,  66,  65,  67,  71,
+     72,  74,  74,  74,  74,  77,  81,  78,
+     72,  73,  82,  85,  89,  88,  84,  80,
+     90, 100,  90,  90,  88,  87,  90,  95,
+    114, 128, 125, 129, 134, 125, 116, 116,
+};
+
+/* Used in CID 1244, 1260 */
+static const uint8_t dnxhd_1260_luma_weight[] = {
+     0, 32, 33, 34, 36, 37, 37, 36,
+    34, 33, 34, 35, 37, 38, 40, 41,
+    40, 39, 38, 37, 34, 33, 34, 37,
+    40, 44, 48, 52, 53, 49, 47, 45,
+    42, 38, 36, 36, 38, 41, 43, 44,
+    46, 49, 52, 54, 54, 49, 44, 44,
+    44, 47, 51, 51, 52, 51, 48, 50,
+    52, 53, 53, 50, 50, 54, 54, 54,
+};
+
+/* Used in CID 1244, 1260 */
+static const uint8_t dnxhd_1260_chroma_weight[] = {
+     0, 32, 34, 38, 42, 40, 38, 36,
+    35, 35, 38, 42, 43, 43, 42, 40,
+    38, 39, 43, 43, 42, 41, 43, 43,
+    42, 44, 46, 45, 45, 46, 47, 46,
+    44, 44, 45, 46, 46, 46, 50, 50,
+    47, 47, 49, 49, 49, 49, 51, 53,
+    51, 49, 53, 57, 56, 52, 50, 52,
+    56, 56, 53, 53, 53, 54, 58, 58,
+};
+
+/* Used in CID 1235, 1236, 1241, 1250, 1256, 1257, 1270, 1271 */
+static const uint8_t dnxhd_1235_dc_codes[14] = {
+    10, 62, 11, 12, 13, 0, 1, 2, 3, 4, 14, 30, 126, 127,
+};
+
+/* Used in CID 1235, 1236, 1241, 1250, 1256, 1257, 1270, 1271 */
+static const uint8_t dnxhd_1235_dc_bits[14] = {
+    4, 6, 4, 4, 4, 3, 3, 3, 3, 3, 4, 5, 7, 7,
+};
+
+/* Used in CID 1237, 1238, 1242, 1243, 1251, 1252, 1253, 1258, 1259, 1260, 1272, 1273, 1274 */
+static const uint8_t dnxhd_1237_dc_codes[12] = {
+    0, 12, 13, 1, 2, 3, 4, 5, 14, 30, 62, 63,
+};
+
+/* Used in CID 1237, 1238, 1242, 1243, 1251, 1252, 1253, 1258, 1259, 1260, 1272, 1273, 1274 */
+static const uint8_t dnxhd_1237_dc_bits[12] = {
+    3, 4, 4, 3, 3, 3, 3, 3, 4, 5, 6, 6,
+};
+
+/* Used in CID 1237, 1242, 1253, 1259, 1260, 1273, 1274 */
+static const uint16_t dnxhd_1237_ac_codes[257] = {
+        0,     1,     4,     5,    12,    26,    27,    56,
+       57,    58,    59,   120,   121,   244,   245,   246,
+      247,   248,   498,   499,   500,   501,   502,  1006,
+     1007,  1008,  1009,  1010,  1011,  2024,  2025,  2026,
+     2027,  2028,  2029,  2030,  2031,  4064,  4065,  4066,
+     4067,  4068,  4069,  4070,  4071,  4072,  4073,  8148,
+     8149,  8150,  8151,  8152,  8153,  8154,  8155,  8156,
+     8157,  8158, 16318, 16319, 16320, 16321, 16322, 16323,
+    16324, 16325, 16326, 16327, 16328, 16329, 16330, 16331,
+    16332, 16333, 32668, 32669, 32670, 32671, 32672, 32673,
+    32674, 32675, 32676, 32677, 32678, 32679, 32680, 32681,
+    32682, 32683, 32684, 65370, 65371, 65372, 65373, 65374,
+    65375, 65376, 65377, 65378, 65379, 65380, 65381, 65382,
+    65383, 65384, 65385, 65386, 65387, 65388, 65389, 65390,
+    65391, 65392, 65393, 65394, 65395, 65396, 65397, 65398,
+    65399, 65400, 65401, 65402, 65403, 65404, 65405, 65406,
+    65407, 65408, 65409, 65410, 65411, 65412, 65413, 65414,
+    65415, 65416, 65417, 65418, 65419, 65420, 65421, 65422,
+    65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430,
+    65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438,
+    65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446,
+    65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454,
+    65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462,
+    65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470,
+    65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478,
+    65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486,
+    65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494,
+    65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502,
+    65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510,
+    65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518,
+    65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526,
+    65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534,
+    65535,
+};
+
+/* Used in CID 1237, 1242, 1253, 1259, 1260, 1273, 1274 */
+static const uint8_t dnxhd_1237_ac_bits[257] = {
+     2,  2,  3,  3,  4,  5,  5,  6,  6,  6,  6,  7,  7,  8,  8,  8,
+     8,  8,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 11, 11, 11,
+    11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13,
+    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16,
+};
+
+/* Used in CID 1237, 1242, 1253, 1259, 1260, 1273, 1274 */
+static const uint8_t dnxhd_1237_ac_info[2*257] = {
+      3, 0,   3, 2,   5, 0,   0, 0,   7, 0,   9, 0,   5, 2,  11, 0,
+     13, 0,  15, 0,   7, 2,  17, 0,  19, 0,  21, 0,  23, 0,  25, 0,
+      9, 2,  11, 2,  27, 0,  29, 0,  31, 0,  33, 0,  13, 2,  35, 0,
+     37, 0,  39, 0,  41, 0,  43, 0,  15, 2,  45, 0,  47, 0,  49, 0,
+     51, 0,  53, 0,  55, 0,  17, 2,  19, 2,  57, 0,  59, 0,  61, 0,
+     63, 0,  65, 0,  67, 0,  69, 0,  21, 2,  23, 2,  25, 2,  71, 0,
+     73, 0,  75, 0,  77, 0,  79, 0,  81, 0,  83, 0,  27, 2,  29, 2,
+     31, 2,  33, 2,  85, 0,  87, 0,  89, 0,  91, 0,  93, 0,  95, 0,
+     97, 0,  99, 0, 101, 0, 103, 0, 105, 0,  35, 2,  37, 2,  39, 2,
+     41, 2,  43, 2, 107, 0, 109, 0, 111, 0, 113, 0, 115, 0, 117, 0,
+    119, 0, 121, 0, 123, 0, 129, 0,   3, 1,  45, 2,  47, 2,  49, 2,
+     51, 2,  53, 2,  55, 2, 125, 0, 127, 0,   5, 1,   7, 1,   9, 1,
+     11, 1,  13, 1,  15, 1,  17, 1,  19, 1,  21, 1,  23, 1,  25, 1,
+     27, 1,  29, 1,  31, 1,  33, 1,  35, 1,  37, 1,  39, 1,  41, 1,
+     43, 1,  45, 1,  47, 1,  49, 1,  51, 1,  53, 1,  55, 1,  57, 1,
+     59, 1,  61, 1,  63, 1,  65, 1,  67, 1,  69, 1,  71, 1,  73, 1,
+     75, 1,  77, 1,  79, 1,  81, 1,  83, 1,  85, 1,  87, 1,  89, 1,
+     91, 1,  93, 1,  95, 1,  97, 1,  99, 1, 101, 1, 103, 1, 105, 1,
+    107, 1, 109, 1, 111, 1, 113, 1, 115, 1, 117, 1, 119, 1, 121, 1,
+    123, 1, 125, 1, 127, 1, 129, 1,  57, 2,  59, 2,  61, 2,  63, 2,
+     65, 2,  67, 2,  69, 2,  71, 2,  73, 2,  75, 2,  77, 2,  79, 2,
+     81, 2,  83, 2,  85, 2,  87, 2,  89, 2,  91, 2,  93, 2,  95, 2,
+     97, 2,  99, 2, 101, 2, 103, 2, 105, 2, 107, 2, 109, 2, 111, 2,
+    113, 2, 115, 2, 117, 2, 119, 2, 121, 2, 123, 2, 125, 2, 127, 2,
+    129, 2,   3, 3,   5, 3,   7, 3,   9, 3,  11, 3,  13, 3,  15, 3,
+     17, 3,  19, 3,  21, 3,  23, 3,  25, 3,  27, 3,  29, 3,  31, 3,
+     33, 3,  35, 3,  37, 3,  39, 3,  41, 3,  43, 3,  45, 3,  47, 3,
+     49, 3,  51, 3,  53, 3,  55, 3,  57, 3,  59, 3,  61, 3,  63, 3,
+     65, 3,  67, 3,  69, 3,  71, 3,  73, 3,  75, 3,  77, 3,  79, 3,
+     81, 3,  83, 3,  85, 3,  87, 3,  89, 3,  91, 3,  93, 3,  95, 3,
+     97, 3,  99, 3, 101, 3, 103, 3, 105, 3, 107, 3, 109, 3, 111, 3,
+    113, 3, 115, 3, 117, 3, 119, 3, 121, 3, 123, 3, 125, 3, 127, 3,
+    129, 3,
+};
+
+/* Used in CID 1238, 1240, 1243, 1272 */
+static const uint16_t dnxhd_1238_ac_codes[257] = {
+        0,     1,     4,    10,    11,    24,    25,    26,
+       54,    55,    56,    57,   116,   117,   118,   119,
+      240,   241,   242,   243,   244,   245,   492,   493,
+      494,   495,   496,   497,   498,   499,  1000,  1001,
+     1002,  1003,  1004,  1005,  1006,  1007,  1008,  2018,
+     2019,  2020,  2021,  2022,  2023,  2024,  2025,  2026,
+     2027,  4056,  4057,  4058,  4059,  4060,  4061,  4062,
+     4063,  4064,  4065,  4066,  4067,  4068,  4069,  8140,
+     8141,  8142,  8143,  8144,  8145,  8146,  8147,  8148,
+     8149,  8150,  8151,  8152,  8153,  8154,  8155,  8156,
+    16314, 16315, 16316, 16317, 16318, 16319, 16320, 16321,
+    16322, 16323, 16324, 16325, 16326, 16327, 16328, 16329,
+    16330, 16331, 16332, 16333, 16334, 16335, 16336, 16337,
+    16338, 32678, 32679, 32680, 32681, 32682, 32683, 32684,
+    32685, 32686, 32687, 32688, 32689, 32690, 32691, 32692,
+    32693, 32694, 32695, 32696, 32697, 32698, 32699, 32700,
+    32701, 32702, 32703, 32704, 32705, 65412, 65413, 65414,
+    65415, 65416, 65417, 65418, 65419, 65420, 65421, 65422,
+    65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430,
+    65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438,
+    65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446,
+    65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454,
+    65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462,
+    65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470,
+    65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478,
+    65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486,
+    65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494,
+    65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502,
+    65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510,
+    65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518,
+    65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526,
+    65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534,
+    65535,
+};
+
+/* Used in CID 1238, 1240, 1243, 1272 */
+static const uint8_t dnxhd_1238_ac_bits[257] = {
+     2,  2,  3,  4,  4,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,
+     8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+    11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13,
+    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16,
+};
+
+/* Used in CID 1238, 1240, 1243, 1272 */
+static const uint8_t dnxhd_1238_ac_info[2*257] = {
+      3, 0,   3, 2,   5, 0,   7, 0,   0, 0,   9, 0,  11, 0,   5, 2,
+     13, 0,  15, 0,  17, 0,   7, 2,  19, 0,  21, 0,  23, 0,   9, 2,
+     25, 0,  27, 0,  29, 0,  31, 0,  33, 0,  11, 2,  35, 0,  37, 0,
+     39, 0,  41, 0,  43, 0,  45, 0,  13, 2,  15, 2,  47, 0,  49, 0,
+     51, 0,  53, 0,  55, 0,  57, 0,  59, 0,  17, 2,  19, 2,  61, 0,
+     63, 0,  65, 0,  67, 0,  69, 0,  71, 0,  73, 0,  75, 0,  21, 2,
+     23, 2,  77, 0,  79, 0,  81, 0,  83, 0,  85, 0,  87, 0,  89, 0,
+     91, 0,  93, 0,  95, 0,  97, 0,  25, 2,  27, 2,  29, 2,  99, 0,
+    101, 0, 103, 0, 105, 0, 107, 0, 109, 0, 111, 0, 113, 0, 115, 0,
+    117, 0, 119, 0, 121, 0, 123, 0,  31, 2,  33, 2,  35, 2,  37, 2,
+    125, 0, 127, 0, 129, 0,   3, 1,   5, 1,   7, 1,   9, 1,  11, 1,
+     13, 1,  15, 1,  17, 1,  19, 1,  21, 1,  23, 1,  25, 1,  27, 1,
+     29, 1,  31, 1,  33, 1,  39, 2,  41, 2,  43, 2,  45, 2,  47, 2,
+     49, 2,  35, 1,  37, 1,  39, 1,  41, 1,  43, 1,  45, 1,  47, 1,
+     49, 1,  51, 1,  53, 1,  55, 1,  57, 1,  59, 1,  61, 1,  63, 1,
+     65, 1,  67, 1,  69, 1,  71, 1,  73, 1,  75, 1,  81, 1,  51, 2,
+     53, 2,  55, 2,  57, 2,  59, 2,  61, 2,  77, 1,  79, 1,  83, 1,
+     85, 1,  87, 1,  89, 1,  91, 1,  93, 1,  95, 1,  97, 1,  99, 1,
+    101, 1, 103, 1, 105, 1, 107, 1, 109, 1, 111, 1, 113, 1, 115, 1,
+    117, 1, 119, 1, 121, 1, 123, 1, 125, 1, 127, 1, 129, 1,  63, 2,
+     65, 2,  67, 2,  69, 2,  71, 2,  73, 2,  75, 2,  77, 2,  79, 2,
+     81, 2,  83, 2,  85, 2,  87, 2,  89, 2,  91, 2,  93, 2,  95, 2,
+     97, 2,  99, 2, 101, 2, 103, 2, 105, 2, 107, 2, 109, 2, 111, 2,
+    113, 2, 115, 2, 117, 2, 119, 2, 121, 2, 123, 2, 125, 2, 127, 2,
+    129, 2,   3, 3,   5, 3,   7, 3,   9, 3,  11, 3,  13, 3,  15, 3,
+     17, 3,  19, 3,  21, 3,  23, 3,  25, 3,  27, 3,  29, 3,  31, 3,
+     33, 3,  35, 3,  37, 3,  39, 3,  41, 3,  43, 3,  45, 3,  47, 3,
+     49, 3,  51, 3,  53, 3,  55, 3,  57, 3,  59, 3,  61, 3,  63, 3,
+     65, 3,  67, 3,  69, 3,  71, 3,  73, 3,  75, 3,  77, 3,  79, 3,
+     81, 3,  83, 3,  85, 3,  87, 3,  89, 3,  91, 3,  93, 3,  95, 3,
+     97, 3,  99, 3, 101, 3, 103, 3, 105, 3, 107, 3, 109, 3, 111, 3,
+    113, 3, 115, 3, 117, 3, 119, 3, 121, 3, 123, 3, 125, 3, 127, 3,
+    129, 3,
+}; /* 0 is EOB */
+
+/* Used in CID 1235, 1236, 1241, 1256, 1257, 1270, 1271 */
+static const uint16_t dnxhd_1235_ac_codes[257] = {
+        0,     1,     4,    10,    11,    24,    25,    26,
+       54,    55,    56,    57,   116,   117,   118,   119,
+      240,   241,   242,   243,   244,   245,   492,   493,
+      494,   495,   496,   497,   498,   998,   999,  1000,
+     1001,  1002,  1003,  1004,  1005,  1006,  1007,  2016,
+     2017,  2018,  2019,  2020,  2021,  2022,  2023,  2024,
+     2025,  2026,  4054,  4055,  4056,  4057,  4058,  4059,
+     4060,  4061,  4062,  4063,  4064,  4065,  4066,  4067,
+     4068,  4069,  8140,  8141,  8142,  8143,  8144,  8145,
+     8146,  8147,  8148,  8149,  8150,  8151,  8152,  8153,
+     8154,  8155,  8156,  8157, 16316, 16317, 16318, 16319,
+    16320, 16321, 16322, 16323, 16324, 16325, 16326, 16327,
+    16328, 16329, 16330, 16331, 16332, 16333, 16334, 16335,
+    16336, 16337, 32676, 32677, 32678, 32679, 32680, 32681,
+    32682, 32683, 32684, 32685, 32686, 32687, 32688, 32689,
+    32690, 32691, 32692, 32693, 32694, 32695, 32696, 32697,
+    32698, 32699, 32700, 32701, 32702, 32703, 32704, 32705,
+    32706, 32707, 32708, 65418, 65419, 65420, 65421, 65422,
+    65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430,
+    65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438,
+    65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446,
+    65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454,
+    65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462,
+    65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470,
+    65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478,
+    65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486,
+    65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494,
+    65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502,
+    65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510,
+    65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518,
+    65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526,
+    65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534,
+    65535,
+};
+
+/* Used in CID 1235, 1236, 1241, 1256, 1257, 1270, 1271 */
+static const uint8_t dnxhd_1235_ac_bits[257] = {
+     2,  2,  3,  4,  4,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,
+     8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+    11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+    12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+    13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16,
+};
+
+/* Used in CID 1235, 1241, 1256, 1270, 1271 */
+static const uint8_t dnxhd_1235_ac_info[2*257] = {
+      3, 0,   3, 2,   5, 0,   7, 0,   0, 0,   9, 0,  11, 0,   5, 2,
+     13, 0,  15, 0,  17, 0,   7, 2,  19, 0,  21, 0,  23, 0,   9, 2,
+     25, 0,  27, 0,  29, 0,  31, 0,  33, 0,  11, 2,  35, 0,  37, 0,
+     39, 0,  41, 0,  43, 0,  13, 2,  15, 2,  45, 0,  47, 0,  49, 0,
+     51, 0,  53, 0,  55, 0,  57, 0,  59, 0,  17, 2,  19, 2,  61, 0,
+     63, 0,  65, 0,  67, 0,  69, 0,  71, 0,  73, 0,  75, 0,  77, 0,
+     21, 2,  23, 2,  79, 0,  81, 0,  83, 0,  85, 0,  87, 0,  89, 0,
+     91, 0,  93, 0,  95, 0,  97, 0,  99, 0, 101, 0,  25, 2,  27, 2,
+     29, 2,  31, 2, 103, 0, 105, 0, 107, 0, 109, 0, 111, 0, 113, 0,
+    115, 0, 117, 0, 119, 0, 121, 0, 123, 0, 125, 0, 127, 0,   3, 1,
+     33, 2,  35, 2,  37, 2,  39, 2, 129, 0,   5, 1,   7, 1,   9, 1,
+     11, 1,  13, 1,  15, 1,  17, 1,  19, 1,  21, 1,  23, 1,  25, 1,
+     27, 1,  29, 1,  31, 1,  33, 1,  35, 1,  41, 2,  43, 2,  45, 2,
+     47, 2,  49, 2,  37, 1,  39, 1,  41, 1,  43, 1,  45, 1,  47, 1,
+     49, 1,  51, 1,  53, 1,  55, 1,  57, 1,  59, 1,  61, 1,  63, 1,
+     65, 1,  67, 1,  69, 1,  71, 1,  73, 1,  75, 1,  77, 1,  79, 1,
+     81, 1,  83, 1,  85, 1,  51, 2,  53, 2,  55, 2,  57, 2,  59, 2,
+     61, 2,  63, 2,  65, 2,  87, 1,  89, 1,  91, 1,  93, 1,  95, 1,
+     97, 1,  99, 1, 101, 1, 103, 1, 105, 1, 107, 1, 109, 1, 111, 1,
+    113, 1, 115, 1, 117, 1, 119, 1, 121, 1, 123, 1, 125, 1, 127, 1,
+    129, 1,  67, 2,  69, 2,  71, 2,  73, 2,  75, 2,  77, 2,  79, 2,
+     81, 2,  83, 2,  85, 2,  87, 2,  89, 2,  91, 2,  93, 2,  95, 2,
+     97, 2,  99, 2, 101, 2, 103, 2, 105, 2, 107, 2, 109, 2, 111, 2,
+    113, 2, 115, 2, 117, 2, 119, 2, 121, 2, 123, 2, 125, 2, 127, 2,
+    129, 2,   3, 3,   5, 3,   7, 3,   9, 3,  11, 3,  13, 3,  15, 3,
+     17, 3,  19, 3,  21, 3,  23, 3,  25, 3,  27, 3,  29, 3,  31, 3,
+     33, 3,  35, 3,  37, 3,  39, 3,  41, 3,  43, 3,  45, 3,  47, 3,
+     49, 3,  51, 3,  53, 3,  55, 3,  57, 3,  59, 3,  61, 3,  63, 3,
+     65, 3,  67, 3,  69, 3,  71, 3,  73, 3,  75, 3,  77, 3,  79, 3,
+     81, 3,  83, 3,  85, 3,  87, 3,  89, 3,  91, 3,  93, 3,  95, 3,
+     97, 3,  99, 3, 101, 3, 103, 3, 105, 3, 107, 3, 109, 3, 111, 3,
+    113, 3, 115, 3, 117, 3, 119, 3, 121, 3, 123, 3, 125, 3, 127, 3,
+    129, 3,
+};
+
+static const uint16_t dnxhd_1250_ac_codes[257] = {
+        0,     1,     4,    10,    11,    24,    25,    26,
+       54,    55,    56,    57,   116,   117,   118,   119,
+      240,   241,   242,   243,   244,   245,   492,   493,
+      494,   495,   496,   497,   498,   998,   999,  1000,
+     1001,  1002,  1003,  1004,  1005,  1006,  2014,  2015,
+     2016,  2017,  2018,  2019,  2020,  2021,  2022,  2023,
+     2024,  2025,  4052,  4053,  4054,  4055,  4056,  4057,
+     4058,  4059,  4060,  4061,  4062,  4063,  4064,  4065,
+     4066,  4067,  8136,  8137,  8138,  8139,  8140,  8141,
+     8142,  8143,  8144,  8145,  8146,  8147,  8148,  8149,
+     8150,  8151,  8152,  8153,  8154,  8155,  8156, 16314,
+    16315, 16316, 16317, 16318, 16319, 16320, 16321, 16322,
+    16323, 16324, 16325, 16326, 16327, 16328, 16329, 16330,
+    16331, 16332, 16333, 16334, 16335, 16336, 16337, 16338,
+    32678, 32679, 32680, 32681, 32682, 32683, 32684, 32685,
+    32686, 32687, 32688, 32689, 32690, 32691, 32692, 32693,
+    32694, 32695, 32696, 32697, 32698, 32699, 32700, 32701,
+    32702, 32703, 32704, 32705, 32706, 32707, 32708, 32709,
+    32710, 32711, 32712, 65426, 65427, 65428, 65429, 65430,
+    65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438,
+    65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446,
+    65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454,
+    65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462,
+    65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470,
+    65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478,
+    65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486,
+    65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494,
+    65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502,
+    65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510,
+    65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518,
+    65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526,
+    65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534,
+    65535
+};
+static const uint8_t dnxhd_1250_ac_bits[257] = {
+     2,  2,  3,  4,  4,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,
+     8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+    11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+    12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+    13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16
+};
+
+static const uint8_t dnxhd_1250_ac_info[2*257] = {
+      3, 0,   3, 2,   5, 0,   7, 0,   0, 0,   9, 0,  11, 0,   5, 2,
+     13, 0,  15, 0,  17, 0,   7, 2,  19, 0,  21, 0,  23, 0,   9, 2,
+     25, 0,  27, 0,  29, 0,  31, 0,  33, 0,  11, 2,  35, 0,  37, 0,
+     39, 0,  41, 0,  43, 0,  45, 0,  13, 2,  47, 0,  49, 0,  51, 0,
+     53, 0,  55, 0,  57, 0,  59, 0,  15, 2,  17, 2,  61, 0,  63, 0,
+     65, 0,  67, 0,  69, 0,  71, 0,  73, 0,  75, 0,  77, 0,  79, 0,
+     19, 2,  21, 2,  81, 0,  83, 0,  85, 0,  87, 0,  89, 0,  91, 0,
+     93, 0,  95, 0,  97, 0,  99, 0, 101, 0, 103, 0, 105, 0,  23, 2,
+     25, 2,  27, 2, 107, 0, 109, 0, 111, 0, 113, 0, 115, 0, 117, 0,
+    119, 0, 121, 0, 123, 0, 125, 0, 127, 0, 129, 0,   3, 1,   5, 1,
+      7, 1,   9, 1,  11, 1,  29, 2,  31, 2,  33, 2,  35, 2,  13, 1,
+     15, 1,  17, 1,  19, 1,  21, 1,  23, 1,  25, 1,  27, 1,  29, 1,
+     31, 1,  33, 1,  35, 1,  37, 1,  39, 1,  41, 1,  43, 1,  45, 1,
+     47, 1,  49, 1,  51, 1,  53, 1,  37, 2,  39, 2,  41, 2,  43, 2,
+     55, 1,  57, 1,  59, 1,  61, 1,  63, 1,  65, 1,  67, 1,  69, 1,
+     71, 1,  73, 1,  75, 1,  77, 1,  79, 1,  81, 1,  83, 1,  85, 1,
+     87, 1,  89, 1,  91, 1,  93, 1,  95, 1,  97, 1,  99, 1, 101, 1,
+    103, 1, 105, 1, 107, 1, 111, 1, 113, 1,  45, 2,  47, 2,  49, 2,
+     51, 2,  53, 2,  55, 2, 109, 1, 115, 1, 117, 1, 119, 1, 121, 1,
+    123, 1, 125, 1, 127, 1, 129, 1,  57, 2,  59, 2,  61, 2,  63, 2,
+     65, 2,  67, 2,  69, 2,  71, 2,  73, 2,  75, 2,  77, 2,  79, 2,
+     81, 2,  83, 2,  85, 2,  87, 2,  89, 2,  91, 2,  93, 2,  95, 2,
+     97, 2,  99, 2, 101, 2, 103, 2, 105, 2, 107, 2, 109, 2, 111, 2,
+    113, 2, 115, 2, 117, 2, 119, 2, 121, 2, 123, 2, 125, 2, 127, 2,
+    129, 2,   3, 3,   5, 3,   7, 3,   9, 3,  11, 3,  13, 3,  15, 3,
+     17, 3,  19, 3,  21, 3,  23, 3,  25, 3,  27, 3,  29, 3,  31, 3,
+     33, 3,  35, 3,  37, 3,  39, 3,  41, 3,  43, 3,  45, 3,  47, 3,
+     49, 3,  51, 3,  53, 3,  55, 3,  57, 3,  59, 3,  61, 3,  63, 3,
+     65, 3,  67, 3,  69, 3,  71, 3,  73, 3,  75, 3,  77, 3,  79, 3,
+     81, 3,  83, 3,  85, 3,  87, 3,  89, 3,  91, 3,  93, 3,  95, 3,
+     97, 3,  99, 3, 101, 3, 103, 3, 105, 3, 107, 3, 109, 3, 111, 3,
+    113, 3, 115, 3, 117, 3, 119, 3, 121, 3, 123, 3, 125, 3, 127, 3,
+    129, 3,
+};
+
+static const uint16_t dnxhd_1251_ac_codes[257] = {
+        0,     1,     4,    10,    11,    24,    25,    26,
+       54,    55,    56,    57,   116,   117,   118,   119,
+      240,   241,   242,   243,   244,   245,   492,   493,
+      494,   495,   496,   497,   996,   997,   998,   999,
+     1000,  1001,  1002,  1003,  1004,  1005,  2012,  2013,
+     2014,  2015,  2016,  2017,  2018,  2019,  2020,  2021,
+     2022,  2023,  2024,  2025,  4052,  4053,  4054,  4055,
+     4056,  4057,  4058,  4059,  4060,  4061,  4062,  4063,
+     4064,  4065,  4066,  8134,  8135,  8136,  8137,  8138,
+     8139,  8140,  8141,  8142,  8143,  8144,  8145,  8146,
+     8147,  8148,  8149,  8150,  8151,  8152,  8153,  8154,
+     8155,  8156, 16314, 16315, 16316, 16317, 16318, 16319,
+    16320, 16321, 16322, 16323, 16324, 16325, 16326, 16327,
+    16328, 16329, 16330, 16331, 16332, 16333, 16334, 16335,
+    16336, 16337, 16338, 16339, 32680, 32681, 32682, 32683,
+    32684, 32685, 32686, 32687, 32688, 32689, 32690, 32691,
+    32692, 32693, 32694, 32695, 32696, 32697, 32698, 32699,
+    32700, 32701, 32702, 32703, 32704, 32705, 32706, 32707,
+    32708, 32709, 32710, 32711, 32712, 32713, 32714, 65430,
+    65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438,
+    65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446,
+    65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454,
+    65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462,
+    65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470,
+    65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478,
+    65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486,
+    65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494,
+    65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502,
+    65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510,
+    65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518,
+    65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526,
+    65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534,
+    65535,
+};
+
+static const uint8_t dnxhd_1251_ac_bits[257] = {
+     2,  2,  3,  4,  4,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,
+     8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+    11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+    12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16,
+};
+
+static const uint8_t dnxhd_1251_ac_info[2*257] = {
+      3, 0,   3, 2,   5, 0,   7, 0,   0, 0,   9, 0,  11, 0,   5, 2,
+     13, 0,  15, 0,  17, 0,   7, 2,  19, 0,  21, 0,  23, 0,   9, 2,
+     25, 0,  27, 0,  29, 0,  31, 0,  33, 0,  11, 2,  35, 0,  37, 0,
+     39, 0,  41, 0,  43, 0,  13, 2,  45, 0,  47, 0,  49, 0,  51, 0,
+     53, 0,  55, 0,  57, 0,  59, 0,  15, 2,  17, 2,  61, 0,  63, 0,
+     65, 0,  67, 0,  69, 0,  71, 0,  73, 0,  75, 0,  77, 0,  79, 0,
+     81, 0,  19, 2,  21, 2,  23, 2,  83, 0,  85, 0,  87, 0,  89, 0,
+     91, 0,  93, 0,  95, 0,  97, 0,  99, 0, 101, 0, 103, 0, 105, 0,
+     25, 2,  27, 2,  29, 2, 107, 0, 109, 0, 111, 0, 113, 0, 115, 0,
+    117, 0, 119, 0, 121, 0, 123, 0, 125, 0, 127, 0, 129, 0,   3, 1,
+      5, 1,   7, 1,   9, 1,  11, 1,  13, 1,  15, 1,  17, 1,  31, 2,
+     33, 2,  35, 2,  19, 1,  21, 1,  23, 1,  25, 1,  27, 1,  29, 1,
+     31, 1,  33, 1,  35, 1,  37, 1,  39, 1,  41, 1,  43, 1,  45, 1,
+     47, 1,  49, 1,  51, 1,  53, 1,  55, 1,  57, 1,  59, 1,  37, 2,
+     39, 2,  41, 2,  43, 2,  45, 2,  61, 1,  63, 1,  65, 1,  67, 1,
+     69, 1,  71, 1,  73, 1,  75, 1,  77, 1,  79, 1,  81, 1,  83, 1,
+     85, 1,  87, 1,  89, 1,  91, 1,  93, 1,  95, 1,  97, 1,  99, 1,
+    101, 1, 103, 1, 105, 1, 107, 1, 109, 1, 111, 1, 113, 1, 115, 1,
+    117, 1,  47, 2,  49, 2,  51, 2,  53, 2,  55, 2,  57, 2, 119, 1,
+    121, 1, 123, 1, 125, 1, 127, 1, 129, 1,  59, 2,  61, 2,  63, 2,
+     65, 2,  67, 2,  69, 2,  71, 2,  73, 2,  75, 2,  77, 2,  79, 2,
+     81, 2,  83, 2,  85, 2,  87, 2,  89, 2,  91, 2,  93, 2,  95, 2,
+     97, 2,  99, 2, 101, 2, 103, 2, 105, 2, 107, 2, 109, 2, 111, 2,
+    113, 2, 115, 2, 117, 2, 119, 2, 121, 2, 123, 2, 125, 2, 127, 2,
+    129, 2,   3, 3,   5, 3,   7, 3,   9, 3,  11, 3,  13, 3,  15, 3,
+     17, 3,  19, 3,  21, 3,  23, 3,  25, 3,  27, 3,  29, 3,  31, 3,
+     33, 3,  35, 3,  37, 3,  39, 3,  41, 3,  43, 3,  45, 3,  47, 3,
+     49, 3,  51, 3,  53, 3,  55, 3,  57, 3,  59, 3,  61, 3,  63, 3,
+     65, 3,  67, 3,  69, 3,  71, 3,  73, 3,  75, 3,  77, 3,  79, 3,
+     81, 3,  83, 3,  85, 3,  87, 3,  89, 3,  91, 3,  93, 3,  95, 3,
+     97, 3,  99, 3, 101, 3, 103, 3, 105, 3, 107, 3, 109, 3, 111, 3,
+    113, 3, 115, 3, 117, 3, 119, 3, 121, 3, 123, 3, 125, 3, 127, 3,
+    129, 3,
+};
+
+/* Used in CID 1252, 1258 */
+static const uint16_t dnxhd_1252_ac_codes[257] = {
+        0,     1,     4,    10,    11,    12,    26,    27,
+       56,    57,    58,   118,   119,   120,   242,   243,
+      244,   245,   246,   247,   496,   497,   498,   499,
+      500,  1002,  1003,  1004,  1005,  1006,  1007,  1008,
+     1009,  2020,  2021,  2022,  2023,  2024,  2025,  2026,
+     2027,  2028,  2029,  4060,  4061,  4062,  4063,  4064,
+     4065,  4066,  4067,  4068,  4069,  4070,  4071,  8144,
+     8145,  8146,  8147,  8148,  8149,  8150,  8151,  8152,
+     8153,  8154,  8155,  8156,  8157,  8158, 16318, 16319,
+    16320, 16321, 16322, 16323, 16324, 16325, 16326, 16327,
+    16328, 16329, 16330, 16331, 16332, 16333, 16334, 16335,
+    32672, 32673, 32674, 32675, 32676, 32677, 32678, 32679,
+    32680, 32681, 32682, 32683, 32684, 32685, 32686, 32687,
+    32688, 32689, 32690, 32691, 32692, 32693, 32694, 65390,
+    65391, 65392, 65393, 65394, 65395, 65396, 65397, 65398,
+    65399, 65400, 65401, 65402, 65403, 65404, 65405, 65406,
+    65407, 65408, 65409, 65410, 65411, 65412, 65413, 65414,
+    65415, 65416, 65417, 65418, 65419, 65420, 65421, 65422,
+    65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430,
+    65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438,
+    65439, 65440, 65441, 65442, 65443, 65444, 65445, 65446,
+    65447, 65448, 65449, 65450, 65451, 65452, 65453, 65454,
+    65455, 65456, 65457, 65458, 65459, 65460, 65461, 65462,
+    65463, 65464, 65465, 65466, 65467, 65468, 65469, 65470,
+    65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478,
+    65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486,
+    65487, 65488, 65489, 65490, 65491, 65492, 65493, 65494,
+    65495, 65496, 65497, 65498, 65499, 65500, 65501, 65502,
+    65503, 65504, 65505, 65506, 65507, 65508, 65509, 65510,
+    65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518,
+    65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526,
+    65527, 65528, 65529, 65530, 65531, 65532, 65533, 65534,
+    65535,
+};
+
+/* Used in CID 1252, 1258 */
+static const uint8_t dnxhd_1252_ac_bits[257] = {
+     2,  2,  3,  4,  4,  4,  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,
+     8,  8,  8,  8,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10,
+    10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12,
+    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+    13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+    16,
+};
+
+/* Used in CID 1252, 1258 */
+static const uint8_t dnxhd_1252_ac_info[2*257] = {
+      3, 0,   3, 2,   5, 0,   7, 0,   5, 2,   0, 0,   9, 0,  11, 0,
+     13, 0,  15, 0,   7, 2,  17, 0,  19, 0,  21, 0,  23, 0,  25, 0,
+     27, 0,  29, 0,   9, 2,  11, 2,  31, 0,  33, 0,  35, 0,  37, 0,
+     13, 2,  39, 0,  41, 0,  43, 0,  45, 0,  47, 0,  49, 0,  15, 2,
+     17, 2,  51, 0,  53, 0,  55, 0,  57, 0,  59, 0,  61, 0,  63, 0,
+     65, 0,  19, 2,  21, 2,  67, 0,  69, 0,  71, 0,  73, 0,  75, 0,
+     77, 0,  79, 0,  81, 0,  83, 0,  23, 2,  25, 2,  27, 2,  85, 0,
+     87, 0,  89, 0,  91, 0,  93, 0,  95, 0,  97, 0,  99, 0, 101, 0,
+    103, 0, 105, 0, 107, 0,  29, 2,  31, 2,  33, 2, 109, 0, 111, 0,
+    113, 0, 115, 0, 117, 0, 119, 0, 121, 0, 123, 0, 125, 0, 127, 0,
+    129, 0,   3, 1,   5, 1,   7, 1,  35, 2,  37, 2,  39, 2,  41, 2,
+      9, 1,  11, 1,  13, 1,  15, 1,  17, 1,  19, 1,  21, 1,  23, 1,
+     25, 1,  27, 1,  29, 1,  31, 1,  33, 1,  35, 1,  37, 1,  39, 1,
+     41, 1,  43, 1,  43, 2,  45, 2,  47, 2,  49, 2,  51, 2,  45, 1,
+     47, 1,  49, 1,  51, 1,  53, 1,  55, 1,  57, 1,  59, 1,  61, 1,
+     63, 1,  65, 1,  67, 1,  69, 1,  71, 1,  73, 1,  75, 1,  77, 1,
+     79, 1,  81, 1,  83, 1,  85, 1,  87, 1,  89, 1,  91, 1,  93, 1,
+     95, 1,  97, 1,  99, 1, 101, 1, 103, 1, 105, 1, 107, 1, 109, 1,
+    111, 1, 113, 1, 115, 1, 117, 1, 119, 1, 121, 1, 123, 1, 125, 1,
+    127, 1, 129, 1,  53, 2,  55, 2,  57, 2,  59, 2,  61, 2,  63, 2,
+     65, 2,  67, 2,  69, 2,  71, 2,  73, 2,  75, 2,  77, 2,  79, 2,
+     81, 2,  83, 2,  85, 2,  87, 2,  89, 2,  91, 2,  93, 2,  95, 2,
+     97, 2,  99, 2, 101, 2, 103, 2, 105, 2, 107, 2, 109, 2, 111, 2,
+    113, 2, 115, 2, 117, 2, 119, 2, 121, 2, 123, 2, 125, 2, 127, 2,
+    129, 2,   3, 3,   5, 3,   7, 3,   9, 3,  11, 3,  13, 3,  15, 3,
+     17, 3,  19, 3,  21, 3,  23, 3,  25, 3,  27, 3,  29, 3,  31, 3,
+     33, 3,  35, 3,  37, 3,  39, 3,  41, 3,  43, 3,  45, 3,  47, 3,
+     49, 3,  51, 3,  53, 3,  55, 3,  57, 3,  59, 3,  61, 3,  63, 3,
+     65, 3,  67, 3,  69, 3,  71, 3,  73, 3,  75, 3,  77, 3,  79, 3,
+     81, 3,  83, 3,  85, 3,  87, 3,  89, 3,  91, 3,  93, 3,  95, 3,
+     97, 3,  99, 3, 101, 3, 103, 3, 105, 3, 107, 3, 109, 3, 111, 3,
+    113, 3, 115, 3, 117, 3, 119, 3, 121, 3, 123, 3, 125, 3, 127, 3,
+    129, 3,
+};
+
+/* Used in CID 1235, 1238, 1241, 1243, 1256, 1270, 1271, 1272 */
+static const uint16_t dnxhd_1235_run_codes[62] = {
+       0,    4,   10,   11,   24,   25,   26,   27,
+      56,   57,   58,   59,  120,  242,  486,  487,
+     488,  489,  980,  981,  982,  983,  984,  985,
+     986,  987,  988,  989,  990,  991,  992,  993,
+     994,  995,  996,  997,  998,  999, 1000, 1001,
+    1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
+    1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017,
+    1018, 1019, 1020, 1021, 1022, 1023,
+};
+
+/* Used in CID 1235, 1238, 1241, 1243, 1256, 1270, 1271, 1272 */
+static const uint8_t dnxhd_1235_run_bits[62] = {
+     1,  3,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  8,  9,  9,
+     9,  9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+};
+
+/* Used in CID 1235, 1241, 1256, 1270, 1271 */
+static const uint8_t dnxhd_1235_run[62] = {
+     1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
+    18, 20, 17, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
+    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
+    49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
+};
+
+/* Used in CID 1237, 1242, 1253, 1259, 1260, 1273, 1274 */
+static const uint16_t dnxhd_1237_run_codes[62] = {
+       0,    4,   10,   11,   24,   25,   26,   54,
+      55,   56,   57,   58,  118,  119,  240,  482,
+     483,  484,  485,  486,  487,  488,  489,  490,
+     491,  492,  493,  494,  990,  991,  992,  993,
+     994,  995,  996,  997,  998,  999, 1000, 1001,
+    1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
+    1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017,
+    1018, 1019, 1020, 1021, 1022, 1023,
+};
+
+/* Used in CID 1237, 1242, 1253, 1259, 1260, 1273, 1274 */
+static const uint8_t dnxhd_1237_run_bits[62] = {
+     1,  3,  4,  4,  5,  5,  5,  6,  6,  6,  6,  6,  7,  7,  8,  9,
+     9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+};
+
+/* Used in CID 1237, 1242, 1253, 1259, 1260, 1273, 1274 */
+static const uint8_t dnxhd_1237_run[62] = {
+     1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
+    17, 18, 19, 20, 21, 53, 57, 58, 59, 60, 61, 62, 22, 23, 24, 25,
+    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56,
+};
+
+/* Used in CID 1238, 1243, 1272 */
+static const uint8_t dnxhd_1238_run[62] = {
+     1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
+    20, 21, 17, 18, 19, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
+    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
+    49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
+};
+
+/* Used in CID 1250, 1251, 1252, 1258 */
+static const uint16_t dnxhd_1250_run_codes[62] = {
+       0,    4,    5,   12,   26,   27,   28,   58,
+     118,  119,  120,  242,  486,  487,  976,  977,
+     978,  979,  980,  981,  982,  983,  984,  985,
+     986,  987,  988,  989,  990,  991,  992,  993,
+     994,  995,  996,  997,  998,  999, 1000, 1001,
+    1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
+    1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017,
+    1018, 1019, 1020, 1021, 1022, 1023,
+};
+
+/* Used in CID 1250, 1251, 1252, 1258 */
+static const uint8_t dnxhd_1250_run_bits[62] = {
+     1,  3,  3,  4,  5,  5,  5,  6,  7,  7,  7,  8,  9,  9, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+};
+
+/* Used in CID 1250, 1251, 1252, 1258 */
+static const uint8_t dnxhd_1250_run[62] = {
+     1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
+    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
+    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
+    49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
+};
+
+const CIDEntry ff_dnxhd_cid_table[] = {
+    { 1235, 1920, 1080, 917504, 917504,
+      0, 6, 10, 4,
+      dnxhd_1235_luma_weight, dnxhd_1235_chroma_weight,
+      dnxhd_1235_dc_codes, dnxhd_1235_dc_bits,
+      dnxhd_1235_ac_codes, dnxhd_1235_ac_bits, dnxhd_1235_ac_info,
+      dnxhd_1235_run_codes, dnxhd_1235_run_bits, dnxhd_1235_run,
+      { 175, 185, 365, 440 } },
+    { 1237, 1920, 1080, 606208, 606208,
+      0, 4, 8, 3,
+      dnxhd_1237_luma_weight, dnxhd_1237_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_info,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 115, 120, 145, 240, 290 } },
+    { 1238, 1920, 1080, 917504, 917504,
+      0, 4, 8, 4,
+      dnxhd_1238_luma_weight, dnxhd_1238_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1238_ac_codes, dnxhd_1238_ac_bits, dnxhd_1238_ac_info,
+      dnxhd_1235_run_codes, dnxhd_1235_run_bits, dnxhd_1238_run,
+      { 175, 185, 220, 365, 440 } },
+    { 1241, 1920, 1080, 917504, 458752,
+      DNXHD_INTERLACED, 6, 10, 4,
+      dnxhd_1241_luma_weight, dnxhd_1241_chroma_weight,
+      dnxhd_1235_dc_codes, dnxhd_1235_dc_bits,
+      dnxhd_1235_ac_codes, dnxhd_1235_ac_bits, dnxhd_1235_ac_info,
+      dnxhd_1235_run_codes, dnxhd_1235_run_bits, dnxhd_1235_run,
+      { 185, 220 } },
+    { 1242, 1920, 1080, 606208, 303104,
+      DNXHD_INTERLACED, 4, 8, 3,
+      dnxhd_1242_luma_weight, dnxhd_1242_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_info,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 120, 145 } },
+    { 1243, 1920, 1080, 917504, 458752,
+      DNXHD_INTERLACED, 4, 8, 4,
+      dnxhd_1243_luma_weight, dnxhd_1243_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1238_ac_codes, dnxhd_1238_ac_bits, dnxhd_1238_ac_info,
+      dnxhd_1235_run_codes, dnxhd_1235_run_bits, dnxhd_1238_run,
+      { 185, 220 } },
+    { 1244, 1440, 1080, 606208, 303104,
+      DNXHD_INTERLACED, 4, 8, 3,
+      dnxhd_1260_luma_weight, dnxhd_1260_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_info,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 120, 145 } },
+    { 1250, 1280,  720, 458752, 458752,
+      0, 6, 10, 4,
+      dnxhd_1250_luma_weight, dnxhd_1250_chroma_weight,
+      dnxhd_1235_dc_codes, dnxhd_1235_dc_bits,
+      dnxhd_1250_ac_codes, dnxhd_1250_ac_bits, dnxhd_1250_ac_info,
+      dnxhd_1250_run_codes, dnxhd_1250_run_bits, dnxhd_1250_run,
+      { 90, 180, 220 } },
+    { 1251, 1280,  720, 458752, 458752,
+      0, 4, 8, 4,
+      dnxhd_1251_luma_weight, dnxhd_1251_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1251_ac_codes, dnxhd_1251_ac_bits, dnxhd_1251_ac_info,
+      dnxhd_1250_run_codes, dnxhd_1250_run_bits, dnxhd_1250_run,
+      { 90, 110, 180, 220 } },
+    { 1252, 1280,  720, 303104, 303104,
+      0, 4, 8, 5,
+      dnxhd_1252_luma_weight, dnxhd_1252_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1252_ac_codes, dnxhd_1252_ac_bits, dnxhd_1252_ac_info,
+      dnxhd_1250_run_codes, dnxhd_1250_run_bits, dnxhd_1250_run,
+      { 60, 75, 120, 145 } },
+    { 1253, 1920, 1080, 188416, 188416,
+      0, 4, 8, 3,
+      dnxhd_1237_luma_weight, dnxhd_1237_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_info,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 36, 45, 75, 90 } },
+    { 1256, 1920, 1080, 1835008, 1835008,
+      DNXHD_444, 6, 10, 4,
+      dnxhd_1235_luma_weight, dnxhd_1235_luma_weight,
+      dnxhd_1235_dc_codes, dnxhd_1235_dc_bits,
+      dnxhd_1235_ac_codes, dnxhd_1235_ac_bits, dnxhd_1235_ac_info,
+      dnxhd_1235_run_codes, dnxhd_1235_run_bits, dnxhd_1235_run,
+      { 350, 390, 440, 730, 880 } },
+    { 1258, 960, 720, 212992, 212992,
+      0, 4, 8, 5,
+      dnxhd_1252_luma_weight, dnxhd_1252_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1252_ac_codes, dnxhd_1252_ac_bits, dnxhd_1252_ac_info,
+      dnxhd_1250_run_codes, dnxhd_1250_run_bits, dnxhd_1250_run,
+      { 42, 60, 75, 115 } },
+    { 1259, 1440, 1080, 417792, 417792,
+      0, 4, 8, 3,
+      dnxhd_1237_luma_weight, dnxhd_1237_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_info,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 63, 84, 100, 110 } },
+    { 1260, 1440, 1080, 835584, 417792,
+      DNXHD_INTERLACED | DNXHD_MBAFF, 4, 8, 3,
+      dnxhd_1260_luma_weight, dnxhd_1260_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_info,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 80, 90, 100, 110 } },
+    { 1270, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE,
+      DNXHD_444, 6, DNXHD_VARIABLE, 4,
+      dnxhd_1235_luma_weight, dnxhd_1235_luma_weight,
+      dnxhd_1235_dc_codes, dnxhd_1235_dc_bits,
+      dnxhd_1235_ac_codes, dnxhd_1235_ac_bits, dnxhd_1235_ac_info,
+      dnxhd_1235_run_codes, dnxhd_1235_run_bits, dnxhd_1235_run,
+      { 0 }, { 57344, 255} },
+    { 1271, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE,
+      0, 6, DNXHD_VARIABLE, 4,
+      dnxhd_1241_luma_weight, dnxhd_1241_chroma_weight,
+      dnxhd_1235_dc_codes, dnxhd_1235_dc_bits,
+      dnxhd_1235_ac_codes, dnxhd_1235_ac_bits, dnxhd_1235_ac_info,
+      dnxhd_1235_run_codes, dnxhd_1235_run_bits, dnxhd_1235_run,
+      { 0 }, { 28672, 255} },
+    { 1272, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE,
+      0, 4, 8, 4,
+      dnxhd_1238_luma_weight, dnxhd_1238_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1238_ac_codes, dnxhd_1238_ac_bits, dnxhd_1238_ac_info,
+      dnxhd_1235_run_codes, dnxhd_1235_run_bits, dnxhd_1238_run,
+      { 0 }, { 28672, 255} },
+    { 1273, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE,
+      0, 4, 8, 3,
+      dnxhd_1237_luma_weight, dnxhd_1237_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_info,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 0 }, { 18944, 255} },
+    { 1274, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE, DNXHD_VARIABLE,
+      0, 4, 8, 3,
+      dnxhd_1237_luma_weight, dnxhd_1237_chroma_weight,
+      dnxhd_1237_dc_codes, dnxhd_1237_dc_bits,
+      dnxhd_1237_ac_codes, dnxhd_1237_ac_bits, dnxhd_1237_ac_info,
+      dnxhd_1237_run_codes, dnxhd_1237_run_bits, dnxhd_1237_run,
+      { 0 }, { 5888, 255} },
+};
+
+int ff_dnxhd_get_cid_table(int cid)
+{
+    int i;
+    for (i = 0; i < FF_ARRAY_ELEMS(ff_dnxhd_cid_table); i++)
+        if (ff_dnxhd_cid_table[i].cid == cid)
+            return i;
+    return -1;
+}
+
+int avpriv_dnxhd_get_frame_size(int cid)
+{
+    int i = ff_dnxhd_get_cid_table(cid);
+    if (i<0)
+        return i;
+    return ff_dnxhd_cid_table[i].frame_size;
+}
+
+int avpriv_dnxhd_get_hr_frame_size(int cid, int w, int h)
+{
+    int result, i = ff_dnxhd_get_cid_table(cid);
+
+    if (i < 0)
+        return i;
+
+    result = ((h + 15) / 16) * ((w + 15) / 16) * (int64_t)ff_dnxhd_cid_table[i].packet_scale.num / ff_dnxhd_cid_table[i].packet_scale.den;
+    result = (result + 2048) / 4096 * 4096;
+
+    return FFMAX(result, 8192);
+}
+
+int avpriv_dnxhd_get_interlaced(int cid)
+{
+    int i = ff_dnxhd_get_cid_table(cid);
+    if (i < 0)
+        return i;
+    return ff_dnxhd_cid_table[i].flags & DNXHD_INTERLACED ? 1 : 0;
+}
+
+static int dnxhd_find_hr_cid(AVCodecContext *avctx)
+{
+    switch (avctx->profile) {
+    case FF_PROFILE_DNXHR_444:
+        return 1270;
+    case FF_PROFILE_DNXHR_HQX:
+        return 1271;
+    case FF_PROFILE_DNXHR_HQ:
+        return 1272;
+    case FF_PROFILE_DNXHR_SQ:
+        return 1273;
+    case FF_PROFILE_DNXHR_LB:
+        return 1274;
+    }
+    return 0;
+}
+
+int ff_dnxhd_find_cid(AVCodecContext *avctx, int bit_depth)
+{
+    int i, j;
+    int mbs = avctx->bit_rate / 1000000;
+
+    if (avctx->profile != FF_PROFILE_DNXHD)
+        return dnxhd_find_hr_cid(avctx);
+
+    if (!mbs)
+        return 0;
+    for (i = 0; i < FF_ARRAY_ELEMS(ff_dnxhd_cid_table); i++) {
+        const CIDEntry *cid = &ff_dnxhd_cid_table[i];
+        int interlaced = cid->flags & DNXHD_INTERLACED ? 1 : 0;
+        if (cid->width == avctx->width && cid->height == avctx->height &&
+            interlaced == !!(avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) &&
+            !(cid->flags & DNXHD_444) && cid->bit_depth == bit_depth) {
+            if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL &&
+                cid->flags & DNXHD_MBAFF) {
+                av_log(avctx, AV_LOG_WARNING, "Profile selected is experimental\n");
+                continue;
+            }
+            for (j = 0; j < FF_ARRAY_ELEMS(cid->bit_rates); j++) {
+                if (cid->bit_rates[j] == mbs)
+                    return cid->cid;
+            }
+        }
+    }
+    return 0;
+}
+
+void ff_dnxhd_print_profiles(AVCodecContext *avctx, int loglevel)
+{
+    int i, j;
+    for (i = 0; i < FF_ARRAY_ELEMS(ff_dnxhd_cid_table); i++) {
+        const CIDEntry *cid = &ff_dnxhd_cid_table[i];
+        for (j = 0; j < FF_ARRAY_ELEMS(cid->bit_rates); j++) {
+            if (!cid->bit_rates[j])
+                break;
+
+            av_log(avctx, loglevel, "Frame size: %dx%d%c; bitrate: %dMbps; pixel format: %s\n",
+                   cid->width, cid->height, cid->flags & DNXHD_INTERLACED ? 'i' : 'p', cid->bit_rates[j],
+                   cid->flags & DNXHD_444 ? "yuv444p10, gbrp10" : cid->bit_depth == 10 ? "yuv422p10" : "yuv422p");
+        }
+    }
+}
diff --git a/libavcodec/dnxhddata.h b/libavcodec/dnxhddata.h
new file mode 100644
index 0000000000..cfa6b0c99d
--- /dev/null
+++ b/libavcodec/dnxhddata.h
@@ -0,0 +1,97 @@
+/*
+ * VC3/DNxHD decoder.
+ * Copyright (c) 2007 SmartJog S.A., Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_DNXHDDATA_H
+#define AVCODEC_DNXHDDATA_H
+
+#include <stdint.h>
+#include "avcodec.h"
+#include "libavutil/internal.h"
+#include "libavutil/intreadwrite.h"
+
+/** Additional profile info flags */
+#define DNXHD_INTERLACED   (1<<0)
+#define DNXHD_MBAFF        (1<<1)
+#define DNXHD_444          (1<<2)
+
+/** Frame headers, extra 0x00 added to end for parser */
+#define DNXHD_HEADER_INITIAL 0x000002800100
+#define DNXHD_HEADER_444     0x000002800200
+
+/** Indicate that a CIDEntry value must be read in the bitstream */
+#define DNXHD_VARIABLE 0
+
+typedef struct CIDEntry {
+    int cid;
+    unsigned int width, height;
+    unsigned int frame_size;
+    unsigned int coding_unit_size;
+    uint16_t flags;
+    int index_bits;
+    int bit_depth;
+    int eob_index;
+    const uint8_t *luma_weight, *chroma_weight;
+    const uint8_t *dc_codes, *dc_bits;
+    const uint16_t *ac_codes;
+    const uint8_t *ac_bits, *ac_info;
+    const uint16_t *run_codes;
+    const uint8_t *run_bits, *run;
+    int bit_rates[5]; ///< Helper to choose variants, rounded to nearest 5Mb/s
+    AVRational packet_scale;
+} CIDEntry;
+
+extern const CIDEntry ff_dnxhd_cid_table[];
+
+int ff_dnxhd_get_cid_table(int cid);
+int ff_dnxhd_find_cid(AVCodecContext *avctx, int bit_depth);
+void ff_dnxhd_print_profiles(AVCodecContext *avctx, int loglevel);
+
+static av_always_inline uint64_t ff_dnxhd_check_header_prefix_hr(uint64_t prefix)
+{
+    uint64_t data_offset = prefix >> 16;
+    if ((prefix & 0xFFFF0000FFFFLL) == 0x0300 &&
+         data_offset >= 0x0280 && data_offset <= 0x2170 &&
+         (data_offset & 3) == 0)
+        return prefix;
+    return 0;
+}
+
+static av_always_inline uint64_t ff_dnxhd_check_header_prefix(uint64_t prefix)
+{
+    if (prefix == DNXHD_HEADER_INITIAL ||
+        prefix == DNXHD_HEADER_444     ||
+        ff_dnxhd_check_header_prefix_hr(prefix))
+        return prefix;
+    return 0;
+}
+
+static av_always_inline uint64_t ff_dnxhd_parse_header_prefix(const uint8_t *buf)
+{
+    uint64_t prefix = AV_RB32(buf);
+    prefix = (prefix << 16) | buf[4] << 8;
+    return ff_dnxhd_check_header_prefix(prefix);
+}
+
+int avpriv_dnxhd_get_frame_size(int cid);
+int avpriv_dnxhd_get_hr_frame_size(int cid, int w, int h);
+int avpriv_dnxhd_get_interlaced(int cid);
+
+#endif /* AVCODEC_DNXHDDATA_H */
diff --git a/libavcodec/dnxhddec.c b/libavcodec/dnxhddec.c
new file mode 100644
index 0000000000..1e95086696
--- /dev/null
+++ b/libavcodec/dnxhddec.c
@@ -0,0 +1,741 @@
+/*
+ * VC3/DNxHD decoder.
+ * Copyright (c) 2007 SmartJog S.A., Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>
+ * Copyright (c) 2011 MirriAd Ltd
+ * Copyright (c) 2015 Christophe Gisquet
+ *
+ * 10 bit support added by MirriAd Ltd, Joseph Artsimovich <joseph@mirriad.com>
+ * Slice multithreading and MB interlaced support added by Christophe Gisquet
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/imgutils.h"
+#include "libavutil/timer.h"
+#include "avcodec.h"
+#include "blockdsp.h"
+#define  UNCHECKED_BITSTREAM_READER 1
+#include "get_bits.h"
+#include "dnxhddata.h"
+#include "idctdsp.h"
+#include "internal.h"
+#include "profiles.h"
+#include "thread.h"
+
+typedef struct RowContext {
+    DECLARE_ALIGNED(32, int16_t, blocks)[12][64];
+    int luma_scale[64];
+    int chroma_scale[64];
+    GetBitContext gb;
+    int last_dc[3];
+    int last_qscale;
+    int errors;
+    /** -1:not set yet  0:off=RGB  1:on=YUV  2:variable */
+    int format;
+} RowContext;
+
+typedef struct DNXHDContext {
+    AVCodecContext *avctx;
+    RowContext *rows;
+    BlockDSPContext bdsp;
+    const uint8_t* buf;
+    int buf_size;
+    int64_t cid;                        ///< compression id
+    unsigned int width, height;
+    enum AVPixelFormat pix_fmt;
+    unsigned int mb_width, mb_height;
+    uint32_t mb_scan_index[512];
+    int data_offset;                    // End of mb_scan_index, where macroblocks start
+    int cur_field;                      ///< current interlaced field
+    VLC ac_vlc, dc_vlc, run_vlc;
+    IDCTDSPContext idsp;
+    ScanTable scantable;
+    const CIDEntry *cid_table;
+    int bit_depth; // 8, 10, 12 or 0 if not initialized at all.
+    int is_444;
+    int alpha;
+    int lla;
+    int mbaff;
+    int act;
+    int (*decode_dct_block)(const struct DNXHDContext *ctx,
+                            RowContext *row, int n);
+} DNXHDContext;
+
+#define DNXHD_VLC_BITS 9
+#define DNXHD_DC_VLC_BITS 7
+
+static int dnxhd_decode_dct_block_8(const DNXHDContext *ctx,
+                                    RowContext *row, int n);
+static int dnxhd_decode_dct_block_10(const DNXHDContext *ctx,
+                                     RowContext *row, int n);
+static int dnxhd_decode_dct_block_10_444(const DNXHDContext *ctx,
+                                         RowContext *row, int n);
+static int dnxhd_decode_dct_block_12(const DNXHDContext *ctx,
+                                     RowContext *row, int n);
+static int dnxhd_decode_dct_block_12_444(const DNXHDContext *ctx,
+                                         RowContext *row, int n);
+
+static av_cold int dnxhd_decode_init(AVCodecContext *avctx)
+{
+    DNXHDContext *ctx = avctx->priv_data;
+
+    ctx->avctx = avctx;
+    ctx->cid = -1;
+    if (avctx->colorspace == AVCOL_SPC_UNSPECIFIED) {
+        avctx->colorspace = AVCOL_SPC_BT709;
+    }
+
+    avctx->coded_width  = FFALIGN(avctx->width,  16);
+    avctx->coded_height = FFALIGN(avctx->height, 16);
+
+    ctx->rows = av_mallocz_array(avctx->thread_count, sizeof(RowContext));
+    if (!ctx->rows)
+        return AVERROR(ENOMEM);
+
+    return 0;
+}
+
+static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)
+{
+    if (cid != ctx->cid) {
+        int index;
+
+        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {
+            av_log(ctx->avctx, AV_LOG_ERROR, "unsupported cid %"PRIu32"\n", cid);
+            return AVERROR(ENOSYS);
+        }
+        if (ff_dnxhd_cid_table[index].bit_depth != bitdepth &&
+            ff_dnxhd_cid_table[index].bit_depth != DNXHD_VARIABLE) {
+            av_log(ctx->avctx, AV_LOG_ERROR, "bit depth mismatches %d %d\n", ff_dnxhd_cid_table[index].bit_depth, bitdepth);
+            return AVERROR_INVALIDDATA;
+        }
+        ctx->cid_table = &ff_dnxhd_cid_table[index];
+        av_log(ctx->avctx, AV_LOG_VERBOSE, "Profile cid %"PRIu32".\n", cid);
+
+        ff_free_vlc(&ctx->ac_vlc);
+        ff_free_vlc(&ctx->dc_vlc);
+        ff_free_vlc(&ctx->run_vlc);
+
+        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
+                 ctx->cid_table->ac_bits, 1, 1,
+                 ctx->cid_table->ac_codes, 2, 2, 0);
+        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,
+                 ctx->cid_table->dc_bits, 1, 1,
+                 ctx->cid_table->dc_codes, 1, 1, 0);
+        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,
+                 ctx->cid_table->run_bits, 1, 1,
+                 ctx->cid_table->run_codes, 2, 2, 0);
+
+        ctx->cid = cid;
+    }
+    return 0;
+}
+
+static av_cold int dnxhd_decode_init_thread_copy(AVCodecContext *avctx)
+{
+    DNXHDContext *ctx = avctx->priv_data;
+
+    ctx->avctx = avctx;
+    // make sure VLC tables will be loaded when cid is parsed
+    ctx->cid = -1;
+
+    ctx->rows = av_mallocz_array(avctx->thread_count, sizeof(RowContext));
+    if (!ctx->rows)
+        return AVERROR(ENOMEM);
+
+    return 0;
+}
+
+static int dnxhd_get_profile(int cid)
+{
+    switch(cid) {
+    case 1270:
+        return FF_PROFILE_DNXHR_444;
+    case 1271:
+        return FF_PROFILE_DNXHR_HQX;
+    case 1272:
+        return FF_PROFILE_DNXHR_HQ;
+    case 1273:
+        return FF_PROFILE_DNXHR_SQ;
+    case 1274:
+        return FF_PROFILE_DNXHR_LB;
+    }
+    return FF_PROFILE_DNXHD;
+}
+
+static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,
+                               const uint8_t *buf, int buf_size,
+                               int first_field)
+{
+    int i, cid, ret;
+    int old_bit_depth = ctx->bit_depth, bitdepth;
+    uint64_t header_prefix;
+    if (buf_size < 0x280) {
+        av_log(ctx->avctx, AV_LOG_ERROR,
+               "buffer too small (%d < 640).\n", buf_size);
+        return AVERROR_INVALIDDATA;
+    }
+
+    header_prefix = ff_dnxhd_parse_header_prefix(buf);
+    if (header_prefix == 0) {
+        av_log(ctx->avctx, AV_LOG_ERROR,
+               "unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n",
+               buf[0], buf[1], buf[2], buf[3], buf[4]);
+        return AVERROR_INVALIDDATA;
+    }
+    if (buf[5] & 2) { /* interlaced */
+        ctx->cur_field = buf[5] & 1;
+        frame->interlaced_frame = 1;
+        frame->top_field_first  = first_field ^ ctx->cur_field;
+        av_log(ctx->avctx, AV_LOG_DEBUG,
+               "interlaced %d, cur field %d\n", buf[5] & 3, ctx->cur_field);
+    } else {
+        ctx->cur_field = 0;
+    }
+    ctx->mbaff = (buf[0x6] >> 5) & 1;
+    ctx->alpha = buf[0x7] & 1;
+    ctx->lla   = (buf[0x7] >> 1) & 1;
+    if (ctx->alpha)
+        avpriv_request_sample(ctx->avctx, "alpha");
+
+    ctx->height = AV_RB16(buf + 0x18);
+    ctx->width  = AV_RB16(buf + 0x1a);
+
+    switch(buf[0x21] >> 5) {
+    case 1: bitdepth = 8; break;
+    case 2: bitdepth = 10; break;
+    case 3: bitdepth = 12; break;
+    default:
+        av_log(ctx->avctx, AV_LOG_ERROR,
+               "Unknown bitdepth indicator (%d)\n", buf[0x21] >> 5);
+        return AVERROR_INVALIDDATA;
+    }
+
+    cid = AV_RB32(buf + 0x28);
+
+    ctx->avctx->profile = dnxhd_get_profile(cid);
+
+    if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)
+        return ret;
+    if (ctx->mbaff && ctx->cid_table->cid != 1260)
+        av_log(ctx->avctx, AV_LOG_WARNING,
+               "Adaptive MB interlace flag in an unsupported profile.\n");
+
+    ctx->act = buf[0x2C] & 7;
+    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)
+        av_log(ctx->avctx, AV_LOG_WARNING,
+               "Adaptive color transform in an unsupported profile.\n");
+
+    ctx->is_444 = (buf[0x2C] >> 6) & 1;
+    if (ctx->is_444) {
+        if (bitdepth == 8) {
+            avpriv_request_sample(ctx->avctx, "4:4:4 8 bits");
+            return AVERROR_INVALIDDATA;
+        } else if (bitdepth == 10) {
+            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;
+            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10
+                                    : AV_PIX_FMT_GBRP10;
+        } else {
+            ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;
+            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12
+                                    : AV_PIX_FMT_GBRP12;
+        }
+    } else if (bitdepth == 12) {
+        ctx->decode_dct_block = dnxhd_decode_dct_block_12;
+        ctx->pix_fmt = AV_PIX_FMT_YUV422P12;
+    } else if (bitdepth == 10) {
+        if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX)
+            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;
+        else
+            ctx->decode_dct_block = dnxhd_decode_dct_block_10;
+        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;
+    } else {
+        ctx->decode_dct_block = dnxhd_decode_dct_block_8;
+        ctx->pix_fmt = AV_PIX_FMT_YUV422P;
+    }
+
+    ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;
+    if (ctx->bit_depth != old_bit_depth) {
+        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);
+        ff_idctdsp_init(&ctx->idsp, ctx->avctx);
+        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,
+                          ff_zigzag_direct);
+    }
+
+    // make sure profile size constraints are respected
+    // DNx100 allows 1920->1440 and 1280->960 subsampling
+    if (ctx->width != ctx->cid_table->width &&
+        ctx->cid_table->width != DNXHD_VARIABLE) {
+        av_reduce(&ctx->avctx->sample_aspect_ratio.num,
+                  &ctx->avctx->sample_aspect_ratio.den,
+                  ctx->width, ctx->cid_table->width, 255);
+        ctx->width = ctx->cid_table->width;
+    }
+
+    if (buf_size < ctx->cid_table->coding_unit_size) {
+        av_log(ctx->avctx, AV_LOG_ERROR, "incorrect frame size (%d < %u).\n",
+               buf_size, ctx->cid_table->coding_unit_size);
+        return AVERROR_INVALIDDATA;
+    }
+
+    ctx->mb_width  = (ctx->width + 15)>> 4;
+    ctx->mb_height = AV_RB16(buf + 0x16c);
+
+    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)
+        ctx->height <<= 1;
+
+    av_log(ctx->avctx, AV_LOG_VERBOSE, "%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n",
+           ctx->width, ctx->height, ctx->is_444 ? "4:4" : "2:2",
+           ctx->bit_depth, ctx->mbaff, ctx->act);
+
+    // Newer format supports variable mb_scan_index sizes
+    if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {
+        ctx->data_offset = 0x170 + (ctx->mb_height << 2);
+    } else {
+        if (ctx->mb_height > 68) {
+            av_log(ctx->avctx, AV_LOG_ERROR,
+                   "mb height too big: %d\n", ctx->mb_height);
+            return AVERROR_INVALIDDATA;
+        }
+        ctx->data_offset = 0x280;
+    }
+    if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
+        av_log(ctx->avctx, AV_LOG_ERROR,
+                "mb height too big: %d\n", ctx->mb_height);
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (buf_size < ctx->data_offset) {
+        av_log(ctx->avctx, AV_LOG_ERROR,
+               "buffer too small (%d < %d).\n", buf_size, ctx->data_offset);
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) {
+        av_log(ctx->avctx, AV_LOG_ERROR,
+               "mb_height too big (%d > %"SIZE_SPECIFIER").\n", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index));
+        return AVERROR_INVALIDDATA;
+    }
+
+    for (i = 0; i < ctx->mb_height; i++) {
+        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));
+        ff_dlog(ctx->avctx, "mb scan index %d, pos %d: %"PRIu32"\n",
+                i, 0x170 + (i << 2), ctx->mb_scan_index[i]);
+        if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {
+            av_log(ctx->avctx, AV_LOG_ERROR,
+                   "invalid mb scan index (%"PRIu32" vs %u).\n",
+                   ctx->mb_scan_index[i], buf_size - ctx->data_offset);
+            return AVERROR_INVALIDDATA;
+        }
+    }
+
+    return 0;
+}
+
+static av_always_inline int dnxhd_decode_dct_block(const DNXHDContext *ctx,
+                                                   RowContext *row,
+                                                   int n,
+                                                   int index_bits,
+                                                   int level_bias,
+                                                   int level_shift,
+                                                   int dc_shift)
+{
+    int i, j, index1, index2, len, flags;
+    int level, component, sign;
+    const int *scale;
+    const uint8_t *weight_matrix;
+    const uint8_t *ac_info = ctx->cid_table->ac_info;
+    int16_t *block = row->blocks[n];
+    const int eob_index     = ctx->cid_table->eob_index;
+    int ret = 0;
+    OPEN_READER(bs, &row->gb);
+
+    ctx->bdsp.clear_block(block);
+
+    if (!ctx->is_444) {
+        if (n & 2) {
+            component     = 1 + (n & 1);
+            scale = row->chroma_scale;
+            weight_matrix = ctx->cid_table->chroma_weight;
+        } else {
+            component     = 0;
+            scale = row->luma_scale;
+            weight_matrix = ctx->cid_table->luma_weight;
+        }
+    } else {
+        component = (n >> 1) % 3;
+        if (component) {
+            scale = row->chroma_scale;
+            weight_matrix = ctx->cid_table->chroma_weight;
+        } else {
+            scale = row->luma_scale;
+            weight_matrix = ctx->cid_table->luma_weight;
+        }
+    }
+
+    UPDATE_CACHE(bs, &row->gb);
+    GET_VLC(len, bs, &row->gb, ctx->dc_vlc.table, DNXHD_DC_VLC_BITS, 1);
+    if (len < 0) {
+        ret = len;
+        goto error;
+    }
+    if (len) {
+        level = GET_CACHE(bs, &row->gb);
+        LAST_SKIP_BITS(bs, &row->gb, len);
+        sign  = ~level >> 31;
+        level = (NEG_USR32(sign ^ level, len) ^ sign) - sign;
+        row->last_dc[component] += level * (1 << dc_shift);
+    }
+    block[0] = row->last_dc[component];
+
+    i = 0;
+
+    UPDATE_CACHE(bs, &row->gb);
+    GET_VLC(index1, bs, &row->gb, ctx->ac_vlc.table,
+            DNXHD_VLC_BITS, 2);
+
+    while (index1 != eob_index) {
+        level = ac_info[2*index1+0];
+        flags = ac_info[2*index1+1];
+
+        sign = SHOW_SBITS(bs, &row->gb, 1);
+        SKIP_BITS(bs, &row->gb, 1);
+
+        if (flags & 1) {
+            level += SHOW_UBITS(bs, &row->gb, index_bits) << 7;
+            SKIP_BITS(bs, &row->gb, index_bits);
+        }
+
+        if (flags & 2) {
+            UPDATE_CACHE(bs, &row->gb);
+            GET_VLC(index2, bs, &row->gb, ctx->run_vlc.table,
+                    DNXHD_VLC_BITS, 2);
+            i += ctx->cid_table->run[index2];
+        }
+
+        if (++i > 63) {
+            av_log(ctx->avctx, AV_LOG_ERROR, "ac tex damaged %d, %d\n", n, i);
+            ret = -1;
+            break;
+        }
+
+        j     = ctx->scantable.permutated[i];
+        level *= scale[i];
+        level += scale[i] >> 1;
+        if (level_bias < 32 || weight_matrix[i] != level_bias)
+            level += level_bias; // 1<<(level_shift-1)
+        level >>= level_shift;
+
+        block[j] = (level ^ sign) - sign;
+
+        UPDATE_CACHE(bs, &row->gb);
+        GET_VLC(index1, bs, &row->gb, ctx->ac_vlc.table,
+                DNXHD_VLC_BITS, 2);
+    }
+error:
+    CLOSE_READER(bs, &row->gb);
+    return ret;
+}
+
+static int dnxhd_decode_dct_block_8(const DNXHDContext *ctx,
+                                    RowContext *row, int n)
+{
+    return dnxhd_decode_dct_block(ctx, row, n, 4, 32, 6, 0);
+}
+
+static int dnxhd_decode_dct_block_10(const DNXHDContext *ctx,
+                                     RowContext *row, int n)
+{
+    return dnxhd_decode_dct_block(ctx, row, n, 6, 8, 4, 0);
+}
+
+static int dnxhd_decode_dct_block_10_444(const DNXHDContext *ctx,
+                                         RowContext *row, int n)
+{
+    return dnxhd_decode_dct_block(ctx, row, n, 6, 32, 6, 0);
+}
+
+static int dnxhd_decode_dct_block_12(const DNXHDContext *ctx,
+                                     RowContext *row, int n)
+{
+    return dnxhd_decode_dct_block(ctx, row, n, 6, 8, 4, 2);
+}
+
+static int dnxhd_decode_dct_block_12_444(const DNXHDContext *ctx,
+                                         RowContext *row, int n)
+{
+    return dnxhd_decode_dct_block(ctx, row, n, 6, 32, 4, 2);
+}
+
+static int dnxhd_decode_macroblock(const DNXHDContext *ctx, RowContext *row,
+                                   AVFrame *frame, int x, int y)
+{
+    int shift1 = ctx->bit_depth >= 10;
+    int dct_linesize_luma   = frame->linesize[0];
+    int dct_linesize_chroma = frame->linesize[1];
+    uint8_t *dest_y, *dest_u, *dest_v;
+    int dct_y_offset, dct_x_offset;
+    int qscale, i, act;
+    int interlaced_mb = 0;
+
+    if (ctx->mbaff) {
+        interlaced_mb = get_bits1(&row->gb);
+        qscale = get_bits(&row->gb, 10);
+    } else {
+        qscale = get_bits(&row->gb, 11);
+    }
+    act = get_bits1(&row->gb);
+    if (act) {
+        if (!ctx->act) {
+            static int act_warned;
+            if (!act_warned) {
+                act_warned = 1;
+                av_log(ctx->avctx, AV_LOG_ERROR,
+                       "ACT flag set, in violation of frame header.\n");
+            }
+        } else if (row->format == -1) {
+            row->format = act;
+        } else if (row->format != act) {
+            row->format = 2; // Variable
+        }
+    }
+
+    if (qscale != row->last_qscale) {
+        for (i = 0; i < 64; i++) {
+            row->luma_scale[i]   = qscale * ctx->cid_table->luma_weight[i];
+            row->chroma_scale[i] = qscale * ctx->cid_table->chroma_weight[i];
+        }
+        row->last_qscale = qscale;
+    }
+
+    for (i = 0; i < 8 + 4 * ctx->is_444; i++) {
+        if (ctx->decode_dct_block(ctx, row, i) < 0)
+            return AVERROR_INVALIDDATA;
+    }
+
+    if (frame->interlaced_frame) {
+        dct_linesize_luma   <<= 1;
+        dct_linesize_chroma <<= 1;
+    }
+
+    dest_y = frame->data[0] + ((y * dct_linesize_luma)   << 4) + (x << (4 + shift1));
+    dest_u = frame->data[1] + ((y * dct_linesize_chroma) << 4) + (x << (3 + shift1 + ctx->is_444));
+    dest_v = frame->data[2] + ((y * dct_linesize_chroma) << 4) + (x << (3 + shift1 + ctx->is_444));
+
+    if (frame->interlaced_frame && ctx->cur_field) {
+        dest_y += frame->linesize[0];
+        dest_u += frame->linesize[1];
+        dest_v += frame->linesize[2];
+    }
+    if (interlaced_mb) {
+        dct_linesize_luma   <<= 1;
+        dct_linesize_chroma <<= 1;
+    }
+
+    dct_y_offset = interlaced_mb ? frame->linesize[0] : (dct_linesize_luma << 3);
+    dct_x_offset = 8 << shift1;
+    if (!ctx->is_444) {
+        ctx->idsp.idct_put(dest_y,                               dct_linesize_luma, row->blocks[0]);
+        ctx->idsp.idct_put(dest_y + dct_x_offset,                dct_linesize_luma, row->blocks[1]);
+        ctx->idsp.idct_put(dest_y + dct_y_offset,                dct_linesize_luma, row->blocks[4]);
+        ctx->idsp.idct_put(dest_y + dct_y_offset + dct_x_offset, dct_linesize_luma, row->blocks[5]);
+
+        if (!(ctx->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+            dct_y_offset = interlaced_mb ? frame->linesize[1] : (dct_linesize_chroma << 3);
+            ctx->idsp.idct_put(dest_u,                dct_linesize_chroma, row->blocks[2]);
+            ctx->idsp.idct_put(dest_v,                dct_linesize_chroma, row->blocks[3]);
+            ctx->idsp.idct_put(dest_u + dct_y_offset, dct_linesize_chroma, row->blocks[6]);
+            ctx->idsp.idct_put(dest_v + dct_y_offset, dct_linesize_chroma, row->blocks[7]);
+        }
+    } else {
+        ctx->idsp.idct_put(dest_y,                               dct_linesize_luma, row->blocks[0]);
+        ctx->idsp.idct_put(dest_y + dct_x_offset,                dct_linesize_luma, row->blocks[1]);
+        ctx->idsp.idct_put(dest_y + dct_y_offset,                dct_linesize_luma, row->blocks[6]);
+        ctx->idsp.idct_put(dest_y + dct_y_offset + dct_x_offset, dct_linesize_luma, row->blocks[7]);
+
+        if (!(ctx->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+            dct_y_offset = interlaced_mb ? frame->linesize[1] : (dct_linesize_chroma << 3);
+            ctx->idsp.idct_put(dest_u,                               dct_linesize_chroma, row->blocks[2]);
+            ctx->idsp.idct_put(dest_u + dct_x_offset,                dct_linesize_chroma, row->blocks[3]);
+            ctx->idsp.idct_put(dest_u + dct_y_offset,                dct_linesize_chroma, row->blocks[8]);
+            ctx->idsp.idct_put(dest_u + dct_y_offset + dct_x_offset, dct_linesize_chroma, row->blocks[9]);
+            ctx->idsp.idct_put(dest_v,                               dct_linesize_chroma, row->blocks[4]);
+            ctx->idsp.idct_put(dest_v + dct_x_offset,                dct_linesize_chroma, row->blocks[5]);
+            ctx->idsp.idct_put(dest_v + dct_y_offset,                dct_linesize_chroma, row->blocks[10]);
+            ctx->idsp.idct_put(dest_v + dct_y_offset + dct_x_offset, dct_linesize_chroma, row->blocks[11]);
+        }
+    }
+
+    return 0;
+}
+
+static int dnxhd_decode_row(AVCodecContext *avctx, void *data,
+                            int rownb, int threadnb)
+{
+    const DNXHDContext *ctx = avctx->priv_data;
+    uint32_t offset = ctx->mb_scan_index[rownb];
+    RowContext *row = ctx->rows + threadnb;
+    int x, ret;
+
+    row->last_dc[0] =
+    row->last_dc[1] =
+    row->last_dc[2] = 1 << (ctx->bit_depth + 2); // for levels +2^(bitdepth-1)
+    ret = init_get_bits8(&row->gb, ctx->buf + offset, ctx->buf_size - offset);
+    if (ret < 0) {
+        row->errors++;
+        return ret;
+    }
+    for (x = 0; x < ctx->mb_width; x++) {
+        //START_TIMER;
+        int ret = dnxhd_decode_macroblock(ctx, row, data, x, rownb);
+        if (ret < 0) {
+            row->errors++;
+            return ret;
+        }
+        //STOP_TIMER("decode macroblock");
+    }
+
+    return 0;
+}
+
+static int dnxhd_decode_frame(AVCodecContext *avctx, void *data,
+                              int *got_frame, AVPacket *avpkt)
+{
+    const uint8_t *buf = avpkt->data;
+    int buf_size = avpkt->size;
+    DNXHDContext *ctx = avctx->priv_data;
+    ThreadFrame frame = { .f = data };
+    AVFrame *picture = data;
+    int first_field = 1;
+    int ret, i;
+
+    ff_dlog(avctx, "frame size %d\n", buf_size);
+
+    for (i = 0; i < avctx->thread_count; i++)
+        ctx->rows[i].format = -1;
+
+decode_coding_unit:
+    if ((ret = dnxhd_decode_header(ctx, picture, buf, buf_size, first_field)) < 0)
+        return ret;
+
+    if ((avctx->width || avctx->height) &&
+        (ctx->width != avctx->width || ctx->height != avctx->height)) {
+        av_log(avctx, AV_LOG_WARNING, "frame size changed: %dx%d -> %ux%u\n",
+               avctx->width, avctx->height, ctx->width, ctx->height);
+        first_field = 1;
+    }
+    if (avctx->pix_fmt != AV_PIX_FMT_NONE && avctx->pix_fmt != ctx->pix_fmt) {
+        av_log(avctx, AV_LOG_WARNING, "pix_fmt changed: %s -> %s\n",
+               av_get_pix_fmt_name(avctx->pix_fmt), av_get_pix_fmt_name(ctx->pix_fmt));
+        first_field = 1;
+    }
+
+    avctx->pix_fmt = ctx->pix_fmt;
+    ret = ff_set_dimensions(avctx, ctx->width, ctx->height);
+    if (ret < 0)
+        return ret;
+
+    if (first_field) {
+        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)
+            return ret;
+        picture->pict_type = AV_PICTURE_TYPE_I;
+        picture->key_frame = 1;
+    }
+
+    ctx->buf_size = buf_size - ctx->data_offset;
+    ctx->buf = buf + ctx->data_offset;
+    avctx->execute2(avctx, dnxhd_decode_row, picture, NULL, ctx->mb_height);
+
+    if (first_field && picture->interlaced_frame) {
+        buf      += ctx->cid_table->coding_unit_size;
+        buf_size -= ctx->cid_table->coding_unit_size;
+        first_field = 0;
+        goto decode_coding_unit;
+    }
+
+    ret = 0;
+    for (i = 0; i < avctx->thread_count; i++) {
+        ret += ctx->rows[i].errors;
+        ctx->rows[i].errors = 0;
+    }
+
+    if (ctx->act) {
+        static int act_warned;
+        int format = ctx->rows[0].format;
+        for (i = 1; i < avctx->thread_count; i++) {
+            if (ctx->rows[i].format != format &&
+                ctx->rows[i].format != -1 /* not run */) {
+                format = 2;
+                break;
+            }
+        }
+        switch (format) {
+        case -1:
+        case 2:
+            if (!act_warned) {
+                act_warned = 1;
+                av_log(ctx->avctx, AV_LOG_ERROR,
+                       "Unsupported: variable ACT flag.\n");
+            }
+            break;
+        case 0:
+            ctx->pix_fmt = ctx->bit_depth==10
+                         ? AV_PIX_FMT_GBRP10 : AV_PIX_FMT_GBRP12;
+            break;
+        case 1:
+            ctx->pix_fmt = ctx->bit_depth==10
+                         ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_YUV444P12;
+            break;
+        }
+    }
+    avctx->pix_fmt = ctx->pix_fmt;
+    if (ret) {
+        av_log(ctx->avctx, AV_LOG_ERROR, "%d lines with errors\n", ret);
+        return AVERROR_INVALIDDATA;
+    }
+
+    *got_frame = 1;
+    return avpkt->size;
+}
+
+static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
+{
+    DNXHDContext *ctx = avctx->priv_data;
+
+    ff_free_vlc(&ctx->ac_vlc);
+    ff_free_vlc(&ctx->dc_vlc);
+    ff_free_vlc(&ctx->run_vlc);
+
+    av_freep(&ctx->rows);
+
+    return 0;
+}
+
+AVCodec ff_dnxhd_decoder = {
+    .name           = "dnxhd",
+    .long_name      = NULL_IF_CONFIG_SMALL("VC3/DNxHD"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_DNXHD,
+    .priv_data_size = sizeof(DNXHDContext),
+    .init           = dnxhd_decode_init,
+    .close          = dnxhd_decode_close,
+    .decode         = dnxhd_decode_frame,
+    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
+                      AV_CODEC_CAP_SLICE_THREADS,
+    .init_thread_copy = ONLY_IF_THREADS_ENABLED(dnxhd_decode_init_thread_copy),
+    .profiles       = NULL_IF_CONFIG_SMALL(ff_dnxhd_profiles),
+};
diff --git a/libavcodec/dnxhdenc.c b/libavcodec/dnxhdenc.c
new file mode 100644
index 0000000000..41b8079a09
--- /dev/null
+++ b/libavcodec/dnxhdenc.c
@@ -0,0 +1,1411 @@
+/*
+ * VC3/DNxHD encoder
+ * Copyright (c) 2007 Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>
+ * Copyright (c) 2011 MirriAd Ltd
+ *
+ * VC-3 encoder funded by the British Broadcasting Corporation
+ * 10 bit support added by MirriAd Ltd, Joseph Artsimovich <joseph@mirriad.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/attributes.h"
+#include "libavutil/internal.h"
+#include "libavutil/opt.h"
+#include "libavutil/timer.h"
+
+#include "avcodec.h"
+#include "blockdsp.h"
+#include "fdctdsp.h"
+#include "internal.h"
+#include "mpegvideo.h"
+#include "pixblockdsp.h"
+#include "profiles.h"
+#include "dnxhdenc.h"
+
+// The largest value that will not lead to overflow for 10-bit samples.
+#define DNX10BIT_QMAT_SHIFT 18
+#define RC_VARIANCE 1 // use variance or ssd for fast rc
+#define LAMBDA_FRAC_BITS 10
+
+#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption options[] = {
+    { "nitris_compat", "encode with Avid Nitris compatibility",
+        offsetof(DNXHDEncContext, nitris_compat), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VE },
+    { "ibias", "intra quant bias",
+        offsetof(DNXHDEncContext, intra_quant_bias), AV_OPT_TYPE_INT,
+        { .i64 = 0 }, INT_MIN, INT_MAX, VE },
+    { "profile",       NULL, offsetof(DNXHDEncContext, profile), AV_OPT_TYPE_INT,
+        { .i64 = FF_PROFILE_DNXHD },
+        FF_PROFILE_DNXHD, FF_PROFILE_DNXHR_444, VE, "profile" },
+    { "dnxhd",     NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_DNXHD },
+        0, 0, VE, "profile" },
+    { "dnxhr_444", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_DNXHR_444 },
+        0, 0, VE, "profile" },
+    { "dnxhr_hqx", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_DNXHR_HQX },
+        0, 0, VE, "profile" },
+    { "dnxhr_hq",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_DNXHR_HQ },
+        0, 0, VE, "profile" },
+    { "dnxhr_sq",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_DNXHR_SQ },
+        0, 0, VE, "profile" },
+    { "dnxhr_lb",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_PROFILE_DNXHR_LB },
+        0, 0, VE, "profile" },
+    { NULL }
+};
+
+static const AVClass dnxhd_class = {
+    .class_name = "dnxhd",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+static void dnxhd_8bit_get_pixels_8x4_sym(int16_t *av_restrict block,
+                                          const uint8_t *pixels,
+                                          ptrdiff_t line_size)
+{
+    int i;
+    for (i = 0; i < 4; i++) {
+        block[0] = pixels[0];
+        block[1] = pixels[1];
+        block[2] = pixels[2];
+        block[3] = pixels[3];
+        block[4] = pixels[4];
+        block[5] = pixels[5];
+        block[6] = pixels[6];
+        block[7] = pixels[7];
+        pixels  += line_size;
+        block   += 8;
+    }
+    memcpy(block,      block -  8, sizeof(*block) * 8);
+    memcpy(block +  8, block - 16, sizeof(*block) * 8);
+    memcpy(block + 16, block - 24, sizeof(*block) * 8);
+    memcpy(block + 24, block - 32, sizeof(*block) * 8);
+}
+
+static av_always_inline
+void dnxhd_10bit_get_pixels_8x4_sym(int16_t *av_restrict block,
+                                    const uint8_t *pixels,
+                                    ptrdiff_t line_size)
+{
+    memcpy(block + 0 * 8, pixels + 0 * line_size, 8 * sizeof(*block));
+    memcpy(block + 7 * 8, pixels + 0 * line_size, 8 * sizeof(*block));
+    memcpy(block + 1 * 8, pixels + 1 * line_size, 8 * sizeof(*block));
+    memcpy(block + 6 * 8, pixels + 1 * line_size, 8 * sizeof(*block));
+    memcpy(block + 2 * 8, pixels + 2 * line_size, 8 * sizeof(*block));
+    memcpy(block + 5 * 8, pixels + 2 * line_size, 8 * sizeof(*block));
+    memcpy(block + 3 * 8, pixels + 3 * line_size, 8 * sizeof(*block));
+    memcpy(block + 4 * 8, pixels + 3 * line_size, 8 * sizeof(*block));
+}
+
+static int dnxhd_10bit_dct_quantize_444(MpegEncContext *ctx, int16_t *block,
+                                        int n, int qscale, int *overflow)
+{
+    int i, j, level, last_non_zero, start_i;
+    const int *qmat;
+    const uint8_t *scantable= ctx->intra_scantable.scantable;
+    int bias;
+    int max = 0;
+    unsigned int threshold1, threshold2;
+
+    ctx->fdsp.fdct(block);
+
+    block[0] = (block[0] + 2) >> 2;
+    start_i = 1;
+    last_non_zero = 0;
+    qmat = n < 4 ? ctx->q_intra_matrix[qscale] : ctx->q_chroma_intra_matrix[qscale];
+    bias= ctx->intra_quant_bias * (1 << (16 - 8));
+    threshold1 = (1 << 16) - bias - 1;
+    threshold2 = (threshold1 << 1);
+
+    for (i = 63; i >= start_i; i--) {
+        j = scantable[i];
+        level = block[j] * qmat[j];
+
+        if (((unsigned)(level + threshold1)) > threshold2) {
+            last_non_zero = i;
+            break;
+        } else{
+            block[j]=0;
+        }
+    }
+
+    for (i = start_i; i <= last_non_zero; i++) {
+        j = scantable[i];
+        level = block[j] * qmat[j];
+
+        if (((unsigned)(level + threshold1)) > threshold2) {
+            if (level > 0) {
+                level = (bias + level) >> 16;
+                block[j] = level;
+            } else{
+                level = (bias - level) >> 16;
+                block[j] = -level;
+            }
+            max |= level;
+        } else {
+            block[j] = 0;
+        }
+    }
+    *overflow = ctx->max_qcoeff < max; //overflow might have happened
+
+    /* we need this permutation so that we correct the IDCT, we only permute the !=0 elements */
+    if (ctx->idsp.perm_type != FF_IDCT_PERM_NONE)
+        ff_block_permute(block, ctx->idsp.idct_permutation,
+                         scantable, last_non_zero);
+
+    return last_non_zero;
+}
+
+static int dnxhd_10bit_dct_quantize(MpegEncContext *ctx, int16_t *block,
+                                    int n, int qscale, int *overflow)
+{
+    const uint8_t *scantable= ctx->intra_scantable.scantable;
+    const int *qmat = n<4 ? ctx->q_intra_matrix[qscale] : ctx->q_chroma_intra_matrix[qscale];
+    int last_non_zero = 0;
+    int i;
+
+    ctx->fdsp.fdct(block);
+
+    // Divide by 4 with rounding, to compensate scaling of DCT coefficients
+    block[0] = (block[0] + 2) >> 2;
+
+    for (i = 1; i < 64; ++i) {
+        int j = scantable[i];
+        int sign = FF_SIGNBIT(block[j]);
+        int level = (block[j] ^ sign) - sign;
+        level = level * qmat[j] >> DNX10BIT_QMAT_SHIFT;
+        block[j] = (level ^ sign) - sign;
+        if (level)
+            last_non_zero = i;
+    }
+
+    /* we need this permutation so that we correct the IDCT, we only permute the !=0 elements */
+    if (ctx->idsp.perm_type != FF_IDCT_PERM_NONE)
+        ff_block_permute(block, ctx->idsp.idct_permutation,
+                         scantable, last_non_zero);
+
+    return last_non_zero;
+}
+
+static av_cold int dnxhd_init_vlc(DNXHDEncContext *ctx)
+{
+    int i, j, level, run;
+    int max_level = 1 << (ctx->bit_depth + 2);
+
+    FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->orig_vlc_codes,
+                      max_level, 4 * sizeof(*ctx->orig_vlc_codes), fail);
+    FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->orig_vlc_bits,
+                      max_level, 4 * sizeof(*ctx->orig_vlc_bits), fail);
+    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->run_codes,
+                      63 * 2, fail);
+    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->run_bits,
+                      63, fail);
+
+    ctx->vlc_codes = ctx->orig_vlc_codes + max_level * 2;
+    ctx->vlc_bits  = ctx->orig_vlc_bits + max_level * 2;
+    for (level = -max_level; level < max_level; level++) {
+        for (run = 0; run < 2; run++) {
+            int index = (level << 1) | run;
+            int sign, offset = 0, alevel = level;
+
+            MASK_ABS(sign, alevel);
+            if (alevel > 64) {
+                offset  = (alevel - 1) >> 6;
+                alevel -= offset << 6;
+            }
+            for (j = 0; j < 257; j++) {
+                if (ctx->cid_table->ac_info[2*j+0] >> 1 == alevel &&
+                    (!offset || (ctx->cid_table->ac_info[2*j+1] & 1) && offset) &&
+                    (!run    || (ctx->cid_table->ac_info[2*j+1] & 2) && run)) {
+                    av_assert1(!ctx->vlc_codes[index]);
+                    if (alevel) {
+                        ctx->vlc_codes[index] =
+                            (ctx->cid_table->ac_codes[j] << 1) | (sign & 1);
+                        ctx->vlc_bits[index] = ctx->cid_table->ac_bits[j] + 1;
+                    } else {
+                        ctx->vlc_codes[index] = ctx->cid_table->ac_codes[j];
+                        ctx->vlc_bits[index]  = ctx->cid_table->ac_bits[j];
+                    }
+                    break;
+                }
+            }
+            av_assert0(!alevel || j < 257);
+            if (offset) {
+                ctx->vlc_codes[index] =
+                    (ctx->vlc_codes[index] << ctx->cid_table->index_bits) | offset;
+                ctx->vlc_bits[index] += ctx->cid_table->index_bits;
+            }
+        }
+    }
+    for (i = 0; i < 62; i++) {
+        int run = ctx->cid_table->run[i];
+        av_assert0(run < 63);
+        ctx->run_codes[run] = ctx->cid_table->run_codes[i];
+        ctx->run_bits[run]  = ctx->cid_table->run_bits[i];
+    }
+    return 0;
+fail:
+    return AVERROR(ENOMEM);
+}
+
+static av_cold int dnxhd_init_qmat(DNXHDEncContext *ctx, int lbias, int cbias)
+{
+    // init first elem to 1 to avoid div by 0 in convert_matrix
+    uint16_t weight_matrix[64] = { 1, }; // convert_matrix needs uint16_t*
+    int qscale, i;
+    const uint8_t *luma_weight_table   = ctx->cid_table->luma_weight;
+    const uint8_t *chroma_weight_table = ctx->cid_table->chroma_weight;
+
+    FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->qmatrix_l,
+                      (ctx->m.avctx->qmax + 1), 64 * sizeof(int), fail);
+    FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->qmatrix_c,
+                      (ctx->m.avctx->qmax + 1), 64 * sizeof(int), fail);
+    FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->qmatrix_l16,
+                      (ctx->m.avctx->qmax + 1), 64 * 2 * sizeof(uint16_t),
+                      fail);
+    FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->qmatrix_c16,
+                      (ctx->m.avctx->qmax + 1), 64 * 2 * sizeof(uint16_t),
+                      fail);
+
+    if (ctx->bit_depth == 8) {
+        for (i = 1; i < 64; i++) {
+            int j = ctx->m.idsp.idct_permutation[ff_zigzag_direct[i]];
+            weight_matrix[j] = ctx->cid_table->luma_weight[i];
+        }
+        ff_convert_matrix(&ctx->m, ctx->qmatrix_l, ctx->qmatrix_l16,
+                          weight_matrix, ctx->intra_quant_bias, 1,
+                          ctx->m.avctx->qmax, 1);
+        for (i = 1; i < 64; i++) {
+            int j = ctx->m.idsp.idct_permutation[ff_zigzag_direct[i]];
+            weight_matrix[j] = ctx->cid_table->chroma_weight[i];
+        }
+        ff_convert_matrix(&ctx->m, ctx->qmatrix_c, ctx->qmatrix_c16,
+                          weight_matrix, ctx->intra_quant_bias, 1,
+                          ctx->m.avctx->qmax, 1);
+
+        for (qscale = 1; qscale <= ctx->m.avctx->qmax; qscale++) {
+            for (i = 0; i < 64; i++) {
+                ctx->qmatrix_l[qscale][i]      <<= 2;
+                ctx->qmatrix_c[qscale][i]      <<= 2;
+                ctx->qmatrix_l16[qscale][0][i] <<= 2;
+                ctx->qmatrix_l16[qscale][1][i] <<= 2;
+                ctx->qmatrix_c16[qscale][0][i] <<= 2;
+                ctx->qmatrix_c16[qscale][1][i] <<= 2;
+            }
+        }
+    } else {
+        // 10-bit
+        for (qscale = 1; qscale <= ctx->m.avctx->qmax; qscale++) {
+            for (i = 1; i < 64; i++) {
+                int j = ff_zigzag_direct[i];
+
+                /* The quantization formula from the VC-3 standard is:
+                 * quantized = sign(block[i]) * floor(abs(block[i]/s) * p /
+                 *             (qscale * weight_table[i]))
+                 * Where p is 32 for 8-bit samples and 8 for 10-bit ones.
+                 * The s factor compensates scaling of DCT coefficients done by
+                 * the DCT routines, and therefore is not present in standard.
+                 * It's 8 for 8-bit samples and 4 for 10-bit ones.
+                 * We want values of ctx->qtmatrix_l and ctx->qtmatrix_r to be:
+                 *     ((1 << DNX10BIT_QMAT_SHIFT) * (p / s)) /
+                 *     (qscale * weight_table[i])
+                 * For 10-bit samples, p / s == 2 */
+                ctx->qmatrix_l[qscale][j] = (1 << (DNX10BIT_QMAT_SHIFT + 1)) /
+                                            (qscale * luma_weight_table[i]);
+                ctx->qmatrix_c[qscale][j] = (1 << (DNX10BIT_QMAT_SHIFT + 1)) /
+                                            (qscale * chroma_weight_table[i]);
+            }
+        }
+    }
+
+    ctx->m.q_chroma_intra_matrix16 = ctx->qmatrix_c16;
+    ctx->m.q_chroma_intra_matrix   = ctx->qmatrix_c;
+    ctx->m.q_intra_matrix16        = ctx->qmatrix_l16;
+    ctx->m.q_intra_matrix          = ctx->qmatrix_l;
+
+    return 0;
+fail:
+    return AVERROR(ENOMEM);
+}
+
+static av_cold int dnxhd_init_rc(DNXHDEncContext *ctx)
+{
+    FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->mb_rc, (ctx->m.avctx->qmax + 1),
+                          ctx->m.mb_num * sizeof(RCEntry), fail);
+    if (ctx->m.avctx->mb_decision != FF_MB_DECISION_RD) {
+        FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->mb_cmp,
+                          ctx->m.mb_num, sizeof(RCCMPEntry), fail);
+        FF_ALLOCZ_ARRAY_OR_GOTO(ctx->m.avctx, ctx->mb_cmp_tmp,
+                          ctx->m.mb_num, sizeof(RCCMPEntry), fail);
+    }
+    ctx->frame_bits = (ctx->coding_unit_size -
+                       ctx->data_offset - 4 - ctx->min_padding) * 8;
+    ctx->qscale = 1;
+    ctx->lambda = 2 << LAMBDA_FRAC_BITS; // qscale 2
+    return 0;
+fail:
+    return AVERROR(ENOMEM);
+}
+
+static av_cold int dnxhd_encode_init(AVCodecContext *avctx)
+{
+    DNXHDEncContext *ctx = avctx->priv_data;
+    int i, index, ret;
+
+    switch (avctx->pix_fmt) {
+    case AV_PIX_FMT_YUV422P:
+        ctx->bit_depth = 8;
+        break;
+    case AV_PIX_FMT_YUV422P10:
+    case AV_PIX_FMT_YUV444P10:
+    case AV_PIX_FMT_GBRP10:
+        ctx->bit_depth = 10;
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR,
+               "pixel format is incompatible with DNxHD\n");
+        return AVERROR(EINVAL);
+    }
+
+    if ((ctx->profile == FF_PROFILE_DNXHR_444 && (avctx->pix_fmt != AV_PIX_FMT_YUV444P10 &&
+                                                  avctx->pix_fmt != AV_PIX_FMT_GBRP10)) ||
+        (ctx->profile != FF_PROFILE_DNXHR_444 && (avctx->pix_fmt == AV_PIX_FMT_YUV444P10 ||
+                                                  avctx->pix_fmt == AV_PIX_FMT_GBRP10))) {
+        av_log(avctx, AV_LOG_ERROR,
+               "pixel format is incompatible with DNxHD profile\n");
+        return AVERROR(EINVAL);
+    }
+
+    if (ctx->profile == FF_PROFILE_DNXHR_HQX && avctx->pix_fmt != AV_PIX_FMT_YUV422P10) {
+        av_log(avctx, AV_LOG_ERROR,
+               "pixel format is incompatible with DNxHR HQX profile\n");
+        return AVERROR(EINVAL);
+    }
+
+    if ((ctx->profile == FF_PROFILE_DNXHR_LB ||
+         ctx->profile == FF_PROFILE_DNXHR_SQ ||
+         ctx->profile == FF_PROFILE_DNXHR_HQ) && avctx->pix_fmt != AV_PIX_FMT_YUV422P) {
+        av_log(avctx, AV_LOG_ERROR,
+               "pixel format is incompatible with DNxHR LB/SQ/HQ profile\n");
+        return AVERROR(EINVAL);
+    }
+
+    ctx->is_444 = ctx->profile == FF_PROFILE_DNXHR_444;
+    avctx->profile = ctx->profile;
+    ctx->cid = ff_dnxhd_find_cid(avctx, ctx->bit_depth);
+    if (!ctx->cid) {
+        av_log(avctx, AV_LOG_ERROR,
+               "video parameters incompatible with DNxHD. Valid DNxHD profiles:\n");
+        ff_dnxhd_print_profiles(avctx, AV_LOG_ERROR);
+        return AVERROR(EINVAL);
+    }
+    av_log(avctx, AV_LOG_DEBUG, "cid %d\n", ctx->cid);
+
+    if (ctx->cid >= 1270 && ctx->cid <= 1274)
+        avctx->codec_tag = MKTAG('A','V','d','h');
+
+    if (avctx->width < 256 || avctx->height < 120) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Input dimensions too small, input must be at least 256x120\n");
+        return AVERROR(EINVAL);
+    }
+
+    index = ff_dnxhd_get_cid_table(ctx->cid);
+    av_assert0(index >= 0);
+
+    ctx->cid_table = &ff_dnxhd_cid_table[index];
+
+    ctx->m.avctx    = avctx;
+    ctx->m.mb_intra = 1;
+    ctx->m.h263_aic = 1;
+
+    avctx->bits_per_raw_sample = ctx->bit_depth;
+
+    ff_blockdsp_init(&ctx->bdsp, avctx);
+    ff_fdctdsp_init(&ctx->m.fdsp, avctx);
+    ff_mpv_idct_init(&ctx->m);
+    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);
+    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);
+    ff_dct_encode_init(&ctx->m);
+
+    if (ctx->profile != FF_PROFILE_DNXHD)
+        ff_videodsp_init(&ctx->m.vdsp, ctx->bit_depth);
+
+    if (!ctx->m.dct_quantize)
+        ctx->m.dct_quantize = ff_dct_quantize_c;
+
+    if (ctx->is_444 || ctx->profile == FF_PROFILE_DNXHR_HQX) {
+        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize_444;
+        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;
+        ctx->block_width_l2     = 4;
+    } else if (ctx->bit_depth == 10) {
+        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;
+        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;
+        ctx->block_width_l2     = 4;
+    } else {
+        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;
+        ctx->block_width_l2     = 3;
+    }
+
+    if (ARCH_X86)
+        ff_dnxhdenc_init_x86(ctx);
+
+    ctx->m.mb_height = (avctx->height + 15) / 16;
+    ctx->m.mb_width  = (avctx->width  + 15) / 16;
+
+    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {
+        ctx->interlaced   = 1;
+        ctx->m.mb_height /= 2;
+    }
+
+    if (ctx->interlaced && ctx->profile != FF_PROFILE_DNXHD) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Interlaced encoding is not supported for DNxHR profiles.\n");
+        return AVERROR(EINVAL);
+    }
+
+    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;
+
+    if (ctx->cid_table->frame_size == DNXHD_VARIABLE) {
+        ctx->frame_size = avpriv_dnxhd_get_hr_frame_size(ctx->cid,
+                                                     avctx->width, avctx->height);
+        av_assert0(ctx->frame_size >= 0);
+        ctx->coding_unit_size = ctx->frame_size;
+    } else {
+        ctx->frame_size = ctx->cid_table->frame_size;
+        ctx->coding_unit_size = ctx->cid_table->coding_unit_size;
+    }
+
+    if (ctx->m.mb_height > 68)
+        ctx->data_offset = 0x170 + (ctx->m.mb_height << 2);
+    else
+        ctx->data_offset = 0x280;
+
+    // XXX tune lbias/cbias
+    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)
+        return ret;
+
+    /* Avid Nitris hardware decoder requires a minimum amount of padding
+     * in the coding unit payload */
+    if (ctx->nitris_compat)
+        ctx->min_padding = 1600;
+
+    if ((ret = dnxhd_init_vlc(ctx)) < 0)
+        return ret;
+    if ((ret = dnxhd_init_rc(ctx)) < 0)
+        return ret;
+
+    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,
+                      ctx->m.mb_height * sizeof(uint32_t), fail);
+    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,
+                      ctx->m.mb_height * sizeof(uint32_t), fail);
+    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,
+                      ctx->m.mb_num * sizeof(uint16_t), fail);
+    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,
+                      ctx->m.mb_num * sizeof(uint8_t), fail);
+
+#if FF_API_CODED_FRAME
+FF_DISABLE_DEPRECATION_WARNINGS
+    avctx->coded_frame->key_frame = 1;
+    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+    if (avctx->active_thread_type == FF_THREAD_SLICE) {
+        if (avctx->thread_count > MAX_THREADS) {
+            av_log(avctx, AV_LOG_ERROR, "too many threads\n");
+            return AVERROR(EINVAL);
+        }
+    }
+
+    if (avctx->qmax <= 1) {
+        av_log(avctx, AV_LOG_ERROR, "qmax must be at least 2\n");
+        return AVERROR(EINVAL);
+    }
+
+    ctx->thread[0] = ctx;
+    if (avctx->active_thread_type == FF_THREAD_SLICE) {
+        for (i = 1; i < avctx->thread_count; i++) {
+            ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));
+            memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));
+        }
+    }
+
+    return 0;
+fail:  // for FF_ALLOCZ_OR_GOTO
+    return AVERROR(ENOMEM);
+}
+
+static int dnxhd_write_header(AVCodecContext *avctx, uint8_t *buf)
+{
+    DNXHDEncContext *ctx = avctx->priv_data;
+
+    memset(buf, 0, ctx->data_offset);
+
+    // * write prefix */
+    AV_WB16(buf + 0x02, ctx->data_offset);
+    if (ctx->cid >= 1270 && ctx->cid <= 1274)
+        buf[4] = 0x03;
+    else
+        buf[4] = 0x01;
+
+    buf[5] = ctx->interlaced ? ctx->cur_field + 2 : 0x01;
+    buf[6] = 0x80; // crc flag off
+    buf[7] = 0xa0; // reserved
+    AV_WB16(buf + 0x18, avctx->height >> ctx->interlaced); // ALPF
+    AV_WB16(buf + 0x1a, avctx->width);  // SPL
+    AV_WB16(buf + 0x1d, avctx->height >> ctx->interlaced); // NAL
+
+    buf[0x21] = ctx->bit_depth == 10 ? 0x58 : 0x38;
+    buf[0x22] = 0x88 + (ctx->interlaced << 2);
+    AV_WB32(buf + 0x28, ctx->cid); // CID
+    buf[0x2c] = (!ctx->interlaced << 7) | (ctx->is_444 << 6) | (avctx->pix_fmt == AV_PIX_FMT_YUV444P10);
+
+    buf[0x5f] = 0x01; // UDL
+
+    buf[0x167] = 0x02; // reserved
+    AV_WB16(buf + 0x16a, ctx->m.mb_height * 4 + 4); // MSIPS
+    AV_WB16(buf + 0x16c, ctx->m.mb_height); // Ns
+    buf[0x16f] = 0x10; // reserved
+
+    ctx->msip = buf + 0x170;
+    return 0;
+}
+
+static av_always_inline void dnxhd_encode_dc(DNXHDEncContext *ctx, int diff)
+{
+    int nbits;
+    if (diff < 0) {
+        nbits = av_log2_16bit(-2 * diff);
+        diff--;
+    } else {
+        nbits = av_log2_16bit(2 * diff);
+    }
+    put_bits(&ctx->m.pb, ctx->cid_table->dc_bits[nbits] + nbits,
+             (ctx->cid_table->dc_codes[nbits] << nbits) +
+             av_mod_uintp2(diff, nbits));
+}
+
+static av_always_inline
+void dnxhd_encode_block(DNXHDEncContext *ctx, int16_t *block,
+                        int last_index, int n)
+{
+    int last_non_zero = 0;
+    int slevel, i, j;
+
+    dnxhd_encode_dc(ctx, block[0] - ctx->m.last_dc[n]);
+    ctx->m.last_dc[n] = block[0];
+
+    for (i = 1; i <= last_index; i++) {
+        j = ctx->m.intra_scantable.permutated[i];
+        slevel = block[j];
+        if (slevel) {
+            int run_level = i - last_non_zero - 1;
+            int rlevel = (slevel << 1) | !!run_level;
+            put_bits(&ctx->m.pb, ctx->vlc_bits[rlevel], ctx->vlc_codes[rlevel]);
+            if (run_level)
+                put_bits(&ctx->m.pb, ctx->run_bits[run_level],
+                         ctx->run_codes[run_level]);
+            last_non_zero = i;
+        }
+    }
+    put_bits(&ctx->m.pb, ctx->vlc_bits[0], ctx->vlc_codes[0]); // EOB
+}
+
+static av_always_inline
+void dnxhd_unquantize_c(DNXHDEncContext *ctx, int16_t *block, int n,
+                        int qscale, int last_index)
+{
+    const uint8_t *weight_matrix;
+    int level;
+    int i;
+
+    if (ctx->is_444) {
+        weight_matrix = ((n % 6) < 2) ? ctx->cid_table->luma_weight
+                                      : ctx->cid_table->chroma_weight;
+    } else {
+        weight_matrix = (n & 2) ? ctx->cid_table->chroma_weight
+                                : ctx->cid_table->luma_weight;
+    }
+
+    for (i = 1; i <= last_index; i++) {
+        int j = ctx->m.intra_scantable.permutated[i];
+        level = block[j];
+        if (level) {
+            if (level < 0) {
+                level = (1 - 2 * level) * qscale * weight_matrix[i];
+                if (ctx->bit_depth == 10) {
+                    if (weight_matrix[i] != 8)
+                        level += 8;
+                    level >>= 4;
+                } else {
+                    if (weight_matrix[i] != 32)
+                        level += 32;
+                    level >>= 6;
+                }
+                level = -level;
+            } else {
+                level = (2 * level + 1) * qscale * weight_matrix[i];
+                if (ctx->bit_depth == 10) {
+                    if (weight_matrix[i] != 8)
+                        level += 8;
+                    level >>= 4;
+                } else {
+                    if (weight_matrix[i] != 32)
+                        level += 32;
+                    level >>= 6;
+                }
+            }
+            block[j] = level;
+        }
+    }
+}
+
+static av_always_inline int dnxhd_ssd_block(int16_t *qblock, int16_t *block)
+{
+    int score = 0;
+    int i;
+    for (i = 0; i < 64; i++)
+        score += (block[i] - qblock[i]) * (block[i] - qblock[i]);
+    return score;
+}
+
+static av_always_inline
+int dnxhd_calc_ac_bits(DNXHDEncContext *ctx, int16_t *block, int last_index)
+{
+    int last_non_zero = 0;
+    int bits = 0;
+    int i, j, level;
+    for (i = 1; i <= last_index; i++) {
+        j = ctx->m.intra_scantable.permutated[i];
+        level = block[j];
+        if (level) {
+            int run_level = i - last_non_zero - 1;
+            bits += ctx->vlc_bits[(level << 1) |
+                    !!run_level] + ctx->run_bits[run_level];
+            last_non_zero = i;
+        }
+    }
+    return bits;
+}
+
+static av_always_inline
+void dnxhd_get_blocks(DNXHDEncContext *ctx, int mb_x, int mb_y)
+{
+    const int bs = ctx->block_width_l2;
+    const int bw = 1 << bs;
+    int dct_y_offset = ctx->dct_y_offset;
+    int dct_uv_offset = ctx->dct_uv_offset;
+    int linesize = ctx->m.linesize;
+    int uvlinesize = ctx->m.uvlinesize;
+    const uint8_t *ptr_y = ctx->thread[0]->src[0] +
+                           ((mb_y << 4) * ctx->m.linesize) + (mb_x << bs + 1);
+    const uint8_t *ptr_u = ctx->thread[0]->src[1] +
+                           ((mb_y << 4) * ctx->m.uvlinesize) + (mb_x << bs + ctx->is_444);
+    const uint8_t *ptr_v = ctx->thread[0]->src[2] +
+                           ((mb_y << 4) * ctx->m.uvlinesize) + (mb_x << bs + ctx->is_444);
+    PixblockDSPContext *pdsp = &ctx->m.pdsp;
+    VideoDSPContext *vdsp = &ctx->m.vdsp;
+
+    if (ctx->bit_depth != 10 && vdsp->emulated_edge_mc && ((mb_x << 4) + 16 > ctx->m.avctx->width ||
+                                                           (mb_y << 4) + 16 > ctx->m.avctx->height)) {
+        int y_w = ctx->m.avctx->width  - (mb_x << 4);
+        int y_h = ctx->m.avctx->height - (mb_y << 4);
+        int uv_w = (y_w + 1) / 2;
+        int uv_h = y_h;
+        linesize = 16;
+        uvlinesize = 8;
+
+        vdsp->emulated_edge_mc(&ctx->edge_buf_y[0], ptr_y,
+                               linesize, ctx->m.linesize,
+                               linesize, 16,
+                               0, 0, y_w, y_h);
+        vdsp->emulated_edge_mc(&ctx->edge_buf_uv[0][0], ptr_u,
+                               uvlinesize, ctx->m.uvlinesize,
+                               uvlinesize, 16,
+                               0, 0, uv_w, uv_h);
+        vdsp->emulated_edge_mc(&ctx->edge_buf_uv[1][0], ptr_v,
+                               uvlinesize, ctx->m.uvlinesize,
+                               uvlinesize, 16,
+                               0, 0, uv_w, uv_h);
+
+        dct_y_offset =  bw * linesize;
+        dct_uv_offset = bw * uvlinesize;
+        ptr_y = &ctx->edge_buf_y[0];
+        ptr_u = &ctx->edge_buf_uv[0][0];
+        ptr_v = &ctx->edge_buf_uv[1][0];
+    } else if (ctx->bit_depth == 10 && vdsp->emulated_edge_mc && ((mb_x << 4) + 16 > ctx->m.avctx->width ||
+                                                                  (mb_y << 4) + 16 > ctx->m.avctx->height)) {
+        int y_w = ctx->m.avctx->width  - (mb_x << 4);
+        int y_h = ctx->m.avctx->height - (mb_y << 4);
+        int uv_w = ctx->is_444 ? y_w : (y_w + 1) / 2;
+        int uv_h = y_h;
+        linesize = 32;
+        uvlinesize = 16 + 16 * ctx->is_444;
+
+        vdsp->emulated_edge_mc(&ctx->edge_buf_y[0], ptr_y,
+                               linesize, ctx->m.linesize,
+                               linesize / 2, 16,
+                               0, 0, y_w, y_h);
+        vdsp->emulated_edge_mc(&ctx->edge_buf_uv[0][0], ptr_u,
+                               uvlinesize, ctx->m.uvlinesize,
+                               uvlinesize / 2, 16,
+                               0, 0, uv_w, uv_h);
+        vdsp->emulated_edge_mc(&ctx->edge_buf_uv[1][0], ptr_v,
+                               uvlinesize, ctx->m.uvlinesize,
+                               uvlinesize / 2, 16,
+                               0, 0, uv_w, uv_h);
+
+        dct_y_offset =  bw * linesize / 2;
+        dct_uv_offset = bw * uvlinesize / 2;
+        ptr_y = &ctx->edge_buf_y[0];
+        ptr_u = &ctx->edge_buf_uv[0][0];
+        ptr_v = &ctx->edge_buf_uv[1][0];
+    }
+
+    if (!ctx->is_444) {
+        pdsp->get_pixels(ctx->blocks[0], ptr_y,      linesize);
+        pdsp->get_pixels(ctx->blocks[1], ptr_y + bw, linesize);
+        pdsp->get_pixels(ctx->blocks[2], ptr_u,      uvlinesize);
+        pdsp->get_pixels(ctx->blocks[3], ptr_v,      uvlinesize);
+
+        if (mb_y + 1 == ctx->m.mb_height && ctx->m.avctx->height == 1080) {
+            if (ctx->interlaced) {
+                ctx->get_pixels_8x4_sym(ctx->blocks[4],
+                                        ptr_y + dct_y_offset,
+                                        linesize);
+                ctx->get_pixels_8x4_sym(ctx->blocks[5],
+                                        ptr_y + dct_y_offset + bw,
+                                        linesize);
+                ctx->get_pixels_8x4_sym(ctx->blocks[6],
+                                        ptr_u + dct_uv_offset,
+                                        uvlinesize);
+                ctx->get_pixels_8x4_sym(ctx->blocks[7],
+                                        ptr_v + dct_uv_offset,
+                                        uvlinesize);
+            } else {
+                ctx->bdsp.clear_block(ctx->blocks[4]);
+                ctx->bdsp.clear_block(ctx->blocks[5]);
+                ctx->bdsp.clear_block(ctx->blocks[6]);
+                ctx->bdsp.clear_block(ctx->blocks[7]);
+            }
+        } else {
+            pdsp->get_pixels(ctx->blocks[4],
+                             ptr_y + dct_y_offset, linesize);
+            pdsp->get_pixels(ctx->blocks[5],
+                             ptr_y + dct_y_offset + bw, linesize);
+            pdsp->get_pixels(ctx->blocks[6],
+                             ptr_u + dct_uv_offset, uvlinesize);
+            pdsp->get_pixels(ctx->blocks[7],
+                             ptr_v + dct_uv_offset, uvlinesize);
+        }
+    } else {
+        pdsp->get_pixels(ctx->blocks[0], ptr_y,      linesize);
+        pdsp->get_pixels(ctx->blocks[1], ptr_y + bw, linesize);
+        pdsp->get_pixels(ctx->blocks[6], ptr_y + dct_y_offset, linesize);
+        pdsp->get_pixels(ctx->blocks[7], ptr_y + dct_y_offset + bw, linesize);
+
+        pdsp->get_pixels(ctx->blocks[2], ptr_u,      uvlinesize);
+        pdsp->get_pixels(ctx->blocks[3], ptr_u + bw, uvlinesize);
+        pdsp->get_pixels(ctx->blocks[8], ptr_u + dct_uv_offset, uvlinesize);
+        pdsp->get_pixels(ctx->blocks[9], ptr_u + dct_uv_offset + bw, uvlinesize);
+
+        pdsp->get_pixels(ctx->blocks[4], ptr_v,      uvlinesize);
+        pdsp->get_pixels(ctx->blocks[5], ptr_v + bw, uvlinesize);
+        pdsp->get_pixels(ctx->blocks[10], ptr_v + dct_uv_offset, uvlinesize);
+        pdsp->get_pixels(ctx->blocks[11], ptr_v + dct_uv_offset + bw, uvlinesize);
+    }
+}
+
+static av_always_inline
+int dnxhd_switch_matrix(DNXHDEncContext *ctx, int i)
+{
+    int x;
+
+    if (ctx->is_444) {
+        x = (i >> 1) % 3;
+    } else {
+        const static uint8_t component[8]={0,0,1,2,0,0,1,2};
+        x = component[i];
+    }
+    return x;
+}
+
+static int dnxhd_calc_bits_thread(AVCodecContext *avctx, void *arg,
+                                  int jobnr, int threadnr)
+{
+    DNXHDEncContext *ctx = avctx->priv_data;
+    int mb_y = jobnr, mb_x;
+    int qscale = ctx->qscale;
+    LOCAL_ALIGNED_16(int16_t, block, [64]);
+    ctx = ctx->thread[threadnr];
+
+    ctx->m.last_dc[0] =
+    ctx->m.last_dc[1] =
+    ctx->m.last_dc[2] = 1 << (ctx->bit_depth + 2);
+
+    for (mb_x = 0; mb_x < ctx->m.mb_width; mb_x++) {
+        unsigned mb = mb_y * ctx->m.mb_width + mb_x;
+        int ssd     = 0;
+        int ac_bits = 0;
+        int dc_bits = 0;
+        int i;
+
+        dnxhd_get_blocks(ctx, mb_x, mb_y);
+
+        for (i = 0; i < 8 + 4 * ctx->is_444; i++) {
+            int16_t *src_block = ctx->blocks[i];
+            int overflow, nbits, diff, last_index;
+            int n = dnxhd_switch_matrix(ctx, i);
+
+            memcpy(block, src_block, 64 * sizeof(*block));
+            last_index = ctx->m.dct_quantize(&ctx->m, block,
+                                             ctx->is_444 ? 4 * (n > 0): 4 & (2*i),
+                                             qscale, &overflow);
+            ac_bits   += dnxhd_calc_ac_bits(ctx, block, last_index);
+
+            diff = block[0] - ctx->m.last_dc[n];
+            if (diff < 0)
+                nbits = av_log2_16bit(-2 * diff);
+            else
+                nbits = av_log2_16bit(2 * diff);
+
+            av_assert1(nbits < ctx->bit_depth + 4);
+            dc_bits += ctx->cid_table->dc_bits[nbits] + nbits;
+
+            ctx->m.last_dc[n] = block[0];
+
+            if (avctx->mb_decision == FF_MB_DECISION_RD || !RC_VARIANCE) {
+                dnxhd_unquantize_c(ctx, block, i, qscale, last_index);
+                ctx->m.idsp.idct(block);
+                ssd += dnxhd_ssd_block(block, src_block);
+            }
+        }
+        ctx->mb_rc[(qscale * ctx->m.mb_num) + mb].ssd  = ssd;
+        ctx->mb_rc[(qscale * ctx->m.mb_num) + mb].bits = ac_bits + dc_bits + 12 +
+                                     (1 + ctx->is_444) * 8 * ctx->vlc_bits[0];
+    }
+    return 0;
+}
+
+static int dnxhd_encode_thread(AVCodecContext *avctx, void *arg,
+                               int jobnr, int threadnr)
+{
+    DNXHDEncContext *ctx = avctx->priv_data;
+    int mb_y = jobnr, mb_x;
+    ctx = ctx->thread[threadnr];
+    init_put_bits(&ctx->m.pb, (uint8_t *)arg + ctx->data_offset + ctx->slice_offs[jobnr],
+                  ctx->slice_size[jobnr]);
+
+    ctx->m.last_dc[0] =
+    ctx->m.last_dc[1] =
+    ctx->m.last_dc[2] = 1 << (ctx->bit_depth + 2);
+    for (mb_x = 0; mb_x < ctx->m.mb_width; mb_x++) {
+        unsigned mb = mb_y * ctx->m.mb_width + mb_x;
+        int qscale = ctx->mb_qscale[mb];
+        int i;
+
+        put_bits(&ctx->m.pb, 11, qscale);
+        put_bits(&ctx->m.pb, 1, avctx->pix_fmt == AV_PIX_FMT_YUV444P10);
+
+        dnxhd_get_blocks(ctx, mb_x, mb_y);
+
+        for (i = 0; i < 8 + 4 * ctx->is_444; i++) {
+            int16_t *block = ctx->blocks[i];
+            int overflow, n = dnxhd_switch_matrix(ctx, i);
+            int last_index = ctx->m.dct_quantize(&ctx->m, block,
+                                                 ctx->is_444 ? (((i >> 1) % 3) < 1 ? 0 : 4): 4 & (2*i),
+                                                 qscale, &overflow);
+            // START_TIMER;
+            dnxhd_encode_block(ctx, block, last_index, n);
+            // STOP_TIMER("encode_block");
+        }
+    }
+    if (put_bits_count(&ctx->m.pb) & 31)
+        put_bits(&ctx->m.pb, 32 - (put_bits_count(&ctx->m.pb) & 31), 0);
+    flush_put_bits(&ctx->m.pb);
+    return 0;
+}
+
+static void dnxhd_setup_threads_slices(DNXHDEncContext *ctx)
+{
+    int mb_y, mb_x;
+    int offset = 0;
+    for (mb_y = 0; mb_y < ctx->m.mb_height; mb_y++) {
+        int thread_size;
+        ctx->slice_offs[mb_y] = offset;
+        ctx->slice_size[mb_y] = 0;
+        for (mb_x = 0; mb_x < ctx->m.mb_width; mb_x++) {
+            unsigned mb = mb_y * ctx->m.mb_width + mb_x;
+            ctx->slice_size[mb_y] += ctx->mb_bits[mb];
+        }
+        ctx->slice_size[mb_y]   = (ctx->slice_size[mb_y] + 31) & ~31;
+        ctx->slice_size[mb_y] >>= 3;
+        thread_size = ctx->slice_size[mb_y];
+        offset += thread_size;
+    }
+}
+
+static int dnxhd_mb_var_thread(AVCodecContext *avctx, void *arg,
+                               int jobnr, int threadnr)
+{
+    DNXHDEncContext *ctx = avctx->priv_data;
+    int mb_y = jobnr, mb_x, x, y;
+    int partial_last_row = (mb_y == ctx->m.mb_height - 1) &&
+                           ((avctx->height >> ctx->interlaced) & 0xF);
+
+    ctx = ctx->thread[threadnr];
+    if (ctx->bit_depth == 8) {
+        uint8_t *pix = ctx->thread[0]->src[0] + ((mb_y << 4) * ctx->m.linesize);
+        for (mb_x = 0; mb_x < ctx->m.mb_width; ++mb_x, pix += 16) {
+            unsigned mb = mb_y * ctx->m.mb_width + mb_x;
+            int sum;
+            int varc;
+
+            if (!partial_last_row && mb_x * 16 <= avctx->width - 16 && (avctx->width % 16) == 0) {
+                sum  = ctx->m.mpvencdsp.pix_sum(pix, ctx->m.linesize);
+                varc = ctx->m.mpvencdsp.pix_norm1(pix, ctx->m.linesize);
+            } else {
+                int bw = FFMIN(avctx->width - 16 * mb_x, 16);
+                int bh = FFMIN((avctx->height >> ctx->interlaced) - 16 * mb_y, 16);
+                sum = varc = 0;
+                for (y = 0; y < bh; y++) {
+                    for (x = 0; x < bw; x++) {
+                        uint8_t val = pix[x + y * ctx->m.linesize];
+                        sum  += val;
+                        varc += val * val;
+                    }
+                }
+            }
+            varc = (varc - (((unsigned) sum * sum) >> 8) + 128) >> 8;
+
+            ctx->mb_cmp[mb].value = varc;
+            ctx->mb_cmp[mb].mb    = mb;
+        }
+    } else { // 10-bit
+        const int linesize = ctx->m.linesize >> 1;
+        for (mb_x = 0; mb_x < ctx->m.mb_width; ++mb_x) {
+            uint16_t *pix = (uint16_t *)ctx->thread[0]->src[0] +
+                            ((mb_y << 4) * linesize) + (mb_x << 4);
+            unsigned mb  = mb_y * ctx->m.mb_width + mb_x;
+            int sum = 0;
+            int sqsum = 0;
+            int bw = FFMIN(avctx->width - 16 * mb_x, 16);
+            int bh = FFMIN((avctx->height >> ctx->interlaced) - 16 * mb_y, 16);
+            int mean, sqmean;
+            int i, j;
+            // Macroblocks are 16x16 pixels, unlike DCT blocks which are 8x8.
+            for (i = 0; i < bh; ++i) {
+                for (j = 0; j < bw; ++j) {
+                    // Turn 16-bit pixels into 10-bit ones.
+                    const int sample = (unsigned) pix[j] >> 6;
+                    sum   += sample;
+                    sqsum += sample * sample;
+                    // 2^10 * 2^10 * 16 * 16 = 2^28, which is less than INT_MAX
+                }
+                pix += linesize;
+            }
+            mean = sum >> 8; // 16*16 == 2^8
+            sqmean = sqsum >> 8;
+            ctx->mb_cmp[mb].value = sqmean - mean * mean;
+            ctx->mb_cmp[mb].mb    = mb;
+        }
+    }
+    return 0;
+}
+
+static int dnxhd_encode_rdo(AVCodecContext *avctx, DNXHDEncContext *ctx)
+{
+    int lambda, up_step, down_step;
+    int last_lower = INT_MAX, last_higher = 0;
+    int x, y, q;
+
+    for (q = 1; q < avctx->qmax; q++) {
+        ctx->qscale = q;
+        avctx->execute2(avctx, dnxhd_calc_bits_thread,
+                        NULL, NULL, ctx->m.mb_height);
+    }
+    up_step = down_step = 2 << LAMBDA_FRAC_BITS;
+    lambda  = ctx->lambda;
+
+    for (;;) {
+        int bits = 0;
+        int end  = 0;
+        if (lambda == last_higher) {
+            lambda++;
+            end = 1; // need to set final qscales/bits
+        }
+        for (y = 0; y < ctx->m.mb_height; y++) {
+            for (x = 0; x < ctx->m.mb_width; x++) {
+                unsigned min = UINT_MAX;
+                int qscale = 1;
+                int mb     = y * ctx->m.mb_width + x;
+                int rc = 0;
+                for (q = 1; q < avctx->qmax; q++) {
+                    int i = (q*ctx->m.mb_num) + mb;
+                    unsigned score = ctx->mb_rc[i].bits * lambda +
+                                     ((unsigned) ctx->mb_rc[i].ssd << LAMBDA_FRAC_BITS);
+                    if (score < min) {
+                        min    = score;
+                        qscale = q;
+                        rc = i;
+                    }
+                }
+                bits += ctx->mb_rc[rc].bits;
+                ctx->mb_qscale[mb] = qscale;
+                ctx->mb_bits[mb]   = ctx->mb_rc[rc].bits;
+            }
+            bits = (bits + 31) & ~31; // padding
+            if (bits > ctx->frame_bits)
+                break;
+        }
+        if (end) {
+            if (bits > ctx->frame_bits)
+                return AVERROR(EINVAL);
+            break;
+        }
+        if (bits < ctx->frame_bits) {
+            last_lower = FFMIN(lambda, last_lower);
+            if (last_higher != 0)
+                lambda = (lambda+last_higher)>>1;
+            else
+                lambda -= down_step;
+            down_step = FFMIN((int64_t)down_step*5, INT_MAX);
+            up_step = 1<<LAMBDA_FRAC_BITS;
+            lambda = FFMAX(1, lambda);
+            if (lambda == last_lower)
+                break;
+        } else {
+            last_higher = FFMAX(lambda, last_higher);
+            if (last_lower != INT_MAX)
+                lambda = (lambda+last_lower)>>1;
+            else if ((int64_t)lambda + up_step > INT_MAX)
+                return AVERROR(EINVAL);
+            else
+                lambda += up_step;
+            up_step = FFMIN((int64_t)up_step*5, INT_MAX);
+            down_step = 1<<LAMBDA_FRAC_BITS;
+        }
+    }
+    ctx->lambda = lambda;
+    return 0;
+}
+
+static int dnxhd_find_qscale(DNXHDEncContext *ctx)
+{
+    int bits = 0;
+    int up_step = 1;
+    int down_step = 1;
+    int last_higher = 0;
+    int last_lower = INT_MAX;
+    int qscale;
+    int x, y;
+
+    qscale = ctx->qscale;
+    for (;;) {
+        bits = 0;
+        ctx->qscale = qscale;
+        // XXX avoid recalculating bits
+        ctx->m.avctx->execute2(ctx->m.avctx, dnxhd_calc_bits_thread,
+                               NULL, NULL, ctx->m.mb_height);
+        for (y = 0; y < ctx->m.mb_height; y++) {
+            for (x = 0; x < ctx->m.mb_width; x++)
+                bits += ctx->mb_rc[(qscale*ctx->m.mb_num) + (y*ctx->m.mb_width+x)].bits;
+            bits = (bits+31)&~31; // padding
+            if (bits > ctx->frame_bits)
+                break;
+        }
+        if (bits < ctx->frame_bits) {
+            if (qscale == 1)
+                return 1;
+            if (last_higher == qscale - 1) {
+                qscale = last_higher;
+                break;
+            }
+            last_lower = FFMIN(qscale, last_lower);
+            if (last_higher != 0)
+                qscale = (qscale + last_higher) >> 1;
+            else
+                qscale -= down_step++;
+            if (qscale < 1)
+                qscale = 1;
+            up_step = 1;
+        } else {
+            if (last_lower == qscale + 1)
+                break;
+            last_higher = FFMAX(qscale, last_higher);
+            if (last_lower != INT_MAX)
+                qscale = (qscale + last_lower) >> 1;
+            else
+                qscale += up_step++;
+            down_step = 1;
+            if (qscale >= ctx->m.avctx->qmax)
+                return AVERROR(EINVAL);
+        }
+    }
+    ctx->qscale = qscale;
+    return 0;
+}
+
+#define BUCKET_BITS 8
+#define RADIX_PASSES 4
+#define NBUCKETS (1 << BUCKET_BITS)
+
+static inline int get_bucket(int value, int shift)
+{
+    value >>= shift;
+    value  &= NBUCKETS - 1;
+    return NBUCKETS - 1 - value;
+}
+
+static void radix_count(const RCCMPEntry *data, int size,
+                        int buckets[RADIX_PASSES][NBUCKETS])
+{
+    int i, j;
+    memset(buckets, 0, sizeof(buckets[0][0]) * RADIX_PASSES * NBUCKETS);
+    for (i = 0; i < size; i++) {
+        int v = data[i].value;
+        for (j = 0; j < RADIX_PASSES; j++) {
+            buckets[j][get_bucket(v, 0)]++;
+            v >>= BUCKET_BITS;
+        }
+        av_assert1(!v);
+    }
+    for (j = 0; j < RADIX_PASSES; j++) {
+        int offset = size;
+        for (i = NBUCKETS - 1; i >= 0; i--)
+            buckets[j][i] = offset -= buckets[j][i];
+        av_assert1(!buckets[j][0]);
+    }
+}
+
+static void radix_sort_pass(RCCMPEntry *dst, const RCCMPEntry *data,
+                            int size, int buckets[NBUCKETS], int pass)
+{
+    int shift = pass * BUCKET_BITS;
+    int i;
+    for (i = 0; i < size; i++) {
+        int v   = get_bucket(data[i].value, shift);
+        int pos = buckets[v]++;
+        dst[pos] = data[i];
+    }
+}
+
+static void radix_sort(RCCMPEntry *data, RCCMPEntry *tmp, int size)
+{
+    int buckets[RADIX_PASSES][NBUCKETS];
+    radix_count(data, size, buckets);
+    radix_sort_pass(tmp, data, size, buckets[0], 0);
+    radix_sort_pass(data, tmp, size, buckets[1], 1);
+    if (buckets[2][NBUCKETS - 1] || buckets[3][NBUCKETS - 1]) {
+        radix_sort_pass(tmp, data, size, buckets[2], 2);
+        radix_sort_pass(data, tmp, size, buckets[3], 3);
+    }
+}
+
+static int dnxhd_encode_fast(AVCodecContext *avctx, DNXHDEncContext *ctx)
+{
+    int max_bits = 0;
+    int ret, x, y;
+    if ((ret = dnxhd_find_qscale(ctx)) < 0)
+        return ret;
+    for (y = 0; y < ctx->m.mb_height; y++) {
+        for (x = 0; x < ctx->m.mb_width; x++) {
+            int mb = y * ctx->m.mb_width + x;
+            int rc = (ctx->qscale * ctx->m.mb_num ) + mb;
+            int delta_bits;
+            ctx->mb_qscale[mb] = ctx->qscale;
+            ctx->mb_bits[mb] = ctx->mb_rc[rc].bits;
+            max_bits += ctx->mb_rc[rc].bits;
+            if (!RC_VARIANCE) {
+                delta_bits = ctx->mb_rc[rc].bits -
+                             ctx->mb_rc[rc + ctx->m.mb_num].bits;
+                ctx->mb_cmp[mb].mb = mb;
+                ctx->mb_cmp[mb].value =
+                    delta_bits ? ((ctx->mb_rc[rc].ssd -
+                                   ctx->mb_rc[rc + ctx->m.mb_num].ssd) * 100) /
+                                  delta_bits
+                               : INT_MIN; // avoid increasing qscale
+            }
+        }
+        max_bits += 31; // worst padding
+    }
+    if (!ret) {
+        if (RC_VARIANCE)
+            avctx->execute2(avctx, dnxhd_mb_var_thread,
+                            NULL, NULL, ctx->m.mb_height);
+        radix_sort(ctx->mb_cmp, ctx->mb_cmp_tmp, ctx->m.mb_num);
+        for (x = 0; x < ctx->m.mb_num && max_bits > ctx->frame_bits; x++) {
+            int mb = ctx->mb_cmp[x].mb;
+            int rc = (ctx->qscale * ctx->m.mb_num ) + mb;
+            max_bits -= ctx->mb_rc[rc].bits -
+                        ctx->mb_rc[rc + ctx->m.mb_num].bits;
+            ctx->mb_qscale[mb] = ctx->qscale + 1;
+            ctx->mb_bits[mb]   = ctx->mb_rc[rc + ctx->m.mb_num].bits;
+        }
+    }
+    return 0;
+}
+
+static void dnxhd_load_picture(DNXHDEncContext *ctx, const AVFrame *frame)
+{
+    int i;
+
+    for (i = 0; i < ctx->m.avctx->thread_count; i++) {
+        ctx->thread[i]->m.linesize    = frame->linesize[0] << ctx->interlaced;
+        ctx->thread[i]->m.uvlinesize  = frame->linesize[1] << ctx->interlaced;
+        ctx->thread[i]->dct_y_offset  = ctx->m.linesize  *8;
+        ctx->thread[i]->dct_uv_offset = ctx->m.uvlinesize*8;
+    }
+
+#if FF_API_CODED_FRAME
+FF_DISABLE_DEPRECATION_WARNINGS
+    ctx->m.avctx->coded_frame->interlaced_frame = frame->interlaced_frame;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    ctx->cur_field = frame->interlaced_frame && !frame->top_field_first;
+}
+
+static int dnxhd_encode_picture(AVCodecContext *avctx, AVPacket *pkt,
+                                const AVFrame *frame, int *got_packet)
+{
+    DNXHDEncContext *ctx = avctx->priv_data;
+    int first_field = 1;
+    int offset, i, ret;
+    uint8_t *buf;
+
+    if ((ret = ff_alloc_packet2(avctx, pkt, ctx->frame_size, 0)) < 0)
+        return ret;
+    buf = pkt->data;
+
+    dnxhd_load_picture(ctx, frame);
+
+encode_coding_unit:
+    for (i = 0; i < 3; i++) {
+        ctx->src[i] = frame->data[i];
+        if (ctx->interlaced && ctx->cur_field)
+            ctx->src[i] += frame->linesize[i];
+    }
+
+    dnxhd_write_header(avctx, buf);
+
+    if (avctx->mb_decision == FF_MB_DECISION_RD)
+        ret = dnxhd_encode_rdo(avctx, ctx);
+    else
+        ret = dnxhd_encode_fast(avctx, ctx);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR,
+               "picture could not fit ratecontrol constraints, increase qmax\n");
+        return ret;
+    }
+
+    dnxhd_setup_threads_slices(ctx);
+
+    offset = 0;
+    for (i = 0; i < ctx->m.mb_height; i++) {
+        AV_WB32(ctx->msip + i * 4, offset);
+        offset += ctx->slice_size[i];
+        av_assert1(!(ctx->slice_size[i] & 3));
+    }
+
+    avctx->execute2(avctx, dnxhd_encode_thread, buf, NULL, ctx->m.mb_height);
+
+    av_assert1(ctx->data_offset + offset + 4 <= ctx->coding_unit_size);
+    memset(buf + ctx->data_offset + offset, 0,
+           ctx->coding_unit_size - 4 - offset - ctx->data_offset);
+
+    AV_WB32(buf + ctx->coding_unit_size - 4, 0x600DC0DE); // EOF
+
+    if (ctx->interlaced && first_field) {
+        first_field     = 0;
+        ctx->cur_field ^= 1;
+        buf            += ctx->coding_unit_size;
+        goto encode_coding_unit;
+    }
+
+#if FF_API_CODED_FRAME
+FF_DISABLE_DEPRECATION_WARNINGS
+    avctx->coded_frame->quality = ctx->qscale * FF_QP2LAMBDA;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+    ff_side_data_set_encoder_stats(pkt, ctx->qscale * FF_QP2LAMBDA, NULL, 0, AV_PICTURE_TYPE_I);
+
+    pkt->flags |= AV_PKT_FLAG_KEY;
+    *got_packet = 1;
+    return 0;
+}
+
+static av_cold int dnxhd_encode_end(AVCodecContext *avctx)
+{
+    DNXHDEncContext *ctx = avctx->priv_data;
+    int i;
+
+    av_freep(&ctx->orig_vlc_codes);
+    av_freep(&ctx->orig_vlc_bits);
+    av_freep(&ctx->run_codes);
+    av_freep(&ctx->run_bits);
+
+    av_freep(&ctx->mb_bits);
+    av_freep(&ctx->mb_qscale);
+    av_freep(&ctx->mb_rc);
+    av_freep(&ctx->mb_cmp);
+    av_freep(&ctx->mb_cmp_tmp);
+    av_freep(&ctx->slice_size);
+    av_freep(&ctx->slice_offs);
+
+    av_freep(&ctx->qmatrix_c);
+    av_freep(&ctx->qmatrix_l);
+    av_freep(&ctx->qmatrix_c16);
+    av_freep(&ctx->qmatrix_l16);
+
+    if (avctx->active_thread_type == FF_THREAD_SLICE) {
+        for (i = 1; i < avctx->thread_count; i++)
+            av_freep(&ctx->thread[i]);
+    }
+
+    return 0;
+}
+
+static const AVCodecDefault dnxhd_defaults[] = {
+    { "qmax", "1024" }, /* Maximum quantization scale factor allowed for VC-3 */
+    { NULL },
+};
+
+AVCodec ff_dnxhd_encoder = {
+    .name           = "dnxhd",
+    .long_name      = NULL_IF_CONFIG_SMALL("VC3/DNxHD"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_DNXHD,
+    .priv_data_size = sizeof(DNXHDEncContext),
+    .init           = dnxhd_encode_init,
+    .encode2        = dnxhd_encode_picture,
+    .close          = dnxhd_encode_end,
+    .capabilities   = AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_INTRA_ONLY,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .pix_fmts       = (const enum AVPixelFormat[]) {
+        AV_PIX_FMT_YUV422P,
+        AV_PIX_FMT_YUV422P10,
+        AV_PIX_FMT_YUV444P10,
+        AV_PIX_FMT_GBRP10,
+        AV_PIX_FMT_NONE
+    },
+    .priv_class     = &dnxhd_class,
+    .defaults       = dnxhd_defaults,
+    .profiles       = NULL_IF_CONFIG_SMALL(ff_dnxhd_profiles),
+};
diff --git a/libavcodec/dnxhdenc.h b/libavcodec/dnxhdenc.h
new file mode 100644
index 0000000000..7b0d862e28
--- /dev/null
+++ b/libavcodec/dnxhdenc.h
@@ -0,0 +1,114 @@
+/*
+ * VC3/DNxHD encoder structure definitions and prototypes
+ * Copyright (c) 2007 Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>
+ *
+ * VC-3 encoder funded by the British Broadcasting Corporation
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_DNXHDENC_H
+#define AVCODEC_DNXHDENC_H
+
+#include <stdint.h>
+
+#include "config.h"
+
+#include "mpegvideo.h"
+#include "dnxhddata.h"
+
+typedef struct RCCMPEntry {
+    uint16_t mb;
+    int value;
+} RCCMPEntry;
+
+typedef struct RCEntry {
+    int ssd;
+    int bits;
+} RCEntry;
+
+typedef struct DNXHDEncContext {
+    AVClass *class;
+    BlockDSPContext bdsp;
+    MpegEncContext m; ///< Used for quantization dsp functions
+
+    int cid;
+    int profile;
+    int bit_depth;
+    int is_444;
+    const CIDEntry *cid_table;
+    uint8_t *msip; ///< Macroblock Scan Indexes Payload
+    uint32_t *slice_size;
+    uint32_t *slice_offs;
+
+    struct DNXHDEncContext *thread[MAX_THREADS];
+
+    // Because our samples are either 8 or 16 bits for 8-bit and 10-bit
+    // encoding respectively, these refer either to bytes or to two-byte words.
+    unsigned dct_y_offset;
+    unsigned dct_uv_offset;
+    unsigned block_width_l2;
+
+    int frame_size;
+    int coding_unit_size;
+    int data_offset;
+
+    int interlaced;
+    int cur_field;
+
+    int nitris_compat;
+    unsigned min_padding;
+    int intra_quant_bias;
+
+    DECLARE_ALIGNED(32, int16_t, blocks)[12][64];
+    DECLARE_ALIGNED(16, uint8_t, edge_buf_y)[512]; // has to hold 16x16 uint16 when depth=10
+    DECLARE_ALIGNED(16, uint8_t, edge_buf_uv)[2][512]; // has to hold 16x16 uint16_t when depth=10
+
+    int      (*qmatrix_c)     [64];
+    int      (*qmatrix_l)     [64];
+    uint16_t (*qmatrix_l16)[2][64];
+    uint16_t (*qmatrix_c16)[2][64];
+
+    unsigned frame_bits;
+    uint8_t *src[3];
+
+    uint32_t *orig_vlc_codes;
+    uint8_t  *orig_vlc_bits;
+    uint32_t *vlc_codes;
+    uint8_t  *vlc_bits;
+    uint16_t *run_codes;
+    uint8_t  *run_bits;
+
+    /** Rate control */
+    unsigned slice_bits;
+    unsigned qscale;
+    unsigned lambda;
+
+    uint16_t *mb_bits;
+    uint8_t  *mb_qscale;
+
+    RCCMPEntry *mb_cmp;
+    RCCMPEntry *mb_cmp_tmp;
+    RCEntry    *mb_rc;
+
+    void (*get_pixels_8x4_sym)(int16_t *av_restrict /* align 16 */ block,
+                               const uint8_t *pixels, ptrdiff_t line_size);
+} DNXHDEncContext;
+
+void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx);
+
+#endif /* AVCODEC_DNXHDENC_H */
diff --git a/libavcodec/x86/dnxhdenc.asm b/libavcodec/x86/dnxhdenc.asm
new file mode 100644
index 0000000000..b4f759552e
--- /dev/null
+++ b/libavcodec/x86/dnxhdenc.asm
@@ -0,0 +1,49 @@
+;************************************************************************
+;* VC3/DNxHD SIMD functions
+;* Copyright (c) 2007 Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>
+;* Copyright (c) 2014 Tiancheng "Timothy" Gu <timothygu99@gmail.com>
+;*
+;* This file is part of FFmpeg.
+;*
+;* FFmpeg is free software; you can redistribute it and/or
+;* modify it under the terms of the GNU Lesser General Public
+;* License as published by the Free Software Foundation; either
+;* version 2.1 of the License, or (at your option) any later version.
+;*
+;* FFmpeg is distributed in the hope that it will be useful,
+;* but WITHOUT ANY WARRANTY; without even the implied warranty of
+;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;* Lesser General Public License for more details.
+;*
+;* You should have received a copy of the GNU Lesser General Public
+;* License along with FFmpeg; if not, write to the Free Software
+;* 51, Inc., Foundation Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+;******************************************************************************
+
+%include "libavutil/x86/x86util.asm"
+
+SECTION .text
+
+; void get_pixels_8x4_sym_sse2(int16_t *block, const uint8_t *pixels,
+;                              ptrdiff_t line_size)
+INIT_XMM sse2
+cglobal get_pixels_8x4_sym, 3,3,5, block, pixels, linesize
+    pxor      m4,       m4
+    movq      m0,       [pixelsq]
+    add       pixelsq,  linesizeq
+    movq      m1,       [pixelsq]
+    movq      m2,       [pixelsq+linesizeq]
+    movq      m3,       [pixelsq+linesizeq*2]
+    punpcklbw m0,       m4
+    punpcklbw m1,       m4
+    punpcklbw m2,       m4
+    punpcklbw m3,       m4
+    mova  [blockq    ], m0
+    mova  [blockq+16 ], m1
+    mova  [blockq+32 ], m2
+    mova  [blockq+48 ], m3
+    mova  [blockq+64 ], m3
+    mova  [blockq+80 ], m2
+    mova  [blockq+96 ], m1
+    mova  [blockq+112], m0
+    RET
diff --git a/libavcodec/x86/dnxhdenc_init.c b/libavcodec/x86/dnxhdenc_init.c
new file mode 100644
index 0000000000..fd6f15005a
--- /dev/null
+++ b/libavcodec/x86/dnxhdenc_init.c
@@ -0,0 +1,37 @@
+/*
+ * VC3/DNxHD SIMD functions
+ * Copyright (c) 2007 Baptiste Coudurier <baptiste dot coudurier at smartjog dot com>
+ *
+ * VC-3 encoder funded by the British Broadcasting Corporation
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/attributes.h"
+#include "libavutil/x86/cpu.h"
+#include "libavcodec/dnxhdenc.h"
+
+void ff_get_pixels_8x4_sym_sse2(int16_t *block, const uint8_t *pixels,
+                                ptrdiff_t line_size);
+
+av_cold void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)
+{
+    if (EXTERNAL_SSE2(av_get_cpu_flags())) {
+        if (ctx->cid_table->bit_depth == 8)
+            ctx->get_pixels_8x4_sym = ff_get_pixels_8x4_sym_sse2;
+    }
+}
-- 
2.23.0

